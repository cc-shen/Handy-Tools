# CS 348 - Introduction to Database Management

## Lecture September 11, 2017

### Topics

1. Why do we use databases?
	- Functionality provided by a Database Management System
2. How do we use a Database Management System?
	- Relational model
	- Foundational query languages and SQL
	- Transactions, concurrency, and recovery
3. How do we design a database?
	- Entity-Relationship (ER) modelling
	- Accommodating and enforcing constraints

### What is "Data"

- ANSI definition,
	- _facts_, _concepts_, or _instructions_ in a formalized manner suitable for humans or by automatic means
	- _meaning_

### Early Data Management - Ancient History

Data are not stored on disk.  
One data set per program. High data redundancy.  
See written notes for diagram.

### File Processing - More Recent History

Data are stored in files with interface between programs and files.  
Various access methods exist (e.g., sequential, indexed, random).  
One file corresponds to one or several programs.  
See written notes for diagram.

### Database Approach

See written notes for diagrams.

### What is a Database

**Database**  
A _large_ and _persistent_ collection of (more-or-less similar) pieces of
information organized in a way that facilitates efficient _retrieval_ and
_modification_.  
=> structure of the _database_ is determined by a **data model**.

Examples:

- a file cabinet
- a library system
- a personnel management system

**Database Management System (DBMS)**  
A program (or set of programs) that manages details related to storage
and access for a database.

### Database Management System

**Idea**  
Abstract common functions and creates a uniform well defined interface for applications accessing data.

1. Data Model, all data stored in a well defined way
2. Access control, only authorized people get to see/modify it
3. Concurrency control, multiple concurrent applications access data
4. Database recovery, nothing gets accidentally lost
5. Database maintenance

### Schema and Instance

A **schema** is a description of the data interface to the database. i.e. _how the data is organized_.

A **database instance** is a database (real data) that conforms to a given schema.  
A schema can (_and typically does_) have many instances.

### Applications of Databases

Original:

- Inventory control
- Payroll
- Banking and financial systems
- Reservation systems

More recent:

- Computer aided design (CAD)
- Software development (CASE, SDE/SFE)
- Telecommunication systems
- E-commerce
- Dynamic/Personalized web content

### Why Database Technology

Data constitute an organization asset $\Rightarrow$ _integrated control_.  
&nbsp;&nbsp;&nbsp; Reduction of redundancy  
&nbsp;&nbsp;&nbsp; Avoidance of inconsistency  
&nbsp;&nbsp;&nbsp; Data integrity  
&nbsp;&nbsp;&nbsp; Shareability  
&nbsp;&nbsp;&nbsp; Improved security

Programmer productivity $\Rightarrow$ _data independence_.  
&nbsp;&nbsp;&nbsp; Programmers do not have to deal with data organization.

### Three Level Schema Architecture

1. _External schema (view)_

	What the application programs and user see; may differ for different users of the same database.

2. _Conceptual schema_

	Description of the logical structure of _all_ data in the database.

3. _Physical schema_

	Description of physical aspects (selection of files, devices, storage algorithms, etc.)

### Data Independence

**Idea**  
Applications do not access data directly but, rather through an abstract data model provided by the DBMS.

Two kinds of data independence:  
_Physical_: applications immune to changes in storage structures.  
_Logical_: applications immune to changes in data organization.

_Note_: one of the most important reason to use a DBMS.

### Transaction

When multiple applications access the same data, undesirable results occur.

**Idea**  
Every application may think it is the sole application accessing the data.  
The DBMS should guarantee correct execution.

A **transaction**, is then, an application-specific atomic and durable unit of work.

Properties of transactions:

- _Atomic_: a transaction occurs entirely, or not at all
- _Consistency_: each transaction preserves the consistency of the database
- _Isolated_: concurrent transactions do not interfere with each other
- _Durable_: a transaction's changes are permanent once completed

### Interfacing to the DBMS

**Data Definition Language** (**DDL**): for specifying schemas,  
&nbsp;&nbsp;&nbsp; May have different DDLs for external schema, conceptual schema, internal schema
&nbsp;&nbsp;&nbsp; Information is stored in the **data dictionary**, or **catalog**

**Data Manipulation Language** (**DML**): for specifying queries and updates,  
&nbsp;&nbsp;&nbsp; **navigational** (procedural)  
&nbsp;&nbsp;&nbsp; **non-navigational** (declarative)

### Types of Database Users

- End User
	- Accesses DB indirectly through forms or other query-generating applications, or
	- Generates ad-hoc queries using the DML
- Application developer
	- Designs and implements applications that accesses the database
- Database administrator (DBA)
	- Manages conceptual schema
	- Assists with application view integration
	- Monitors and tunes DBMS performance

### Brief History of Data Management

#### Ancient

2000 BC: Sumerian Records  
&nbsp; 350 BC: _Syllogisms (Aristotle)_  
&nbsp; 296 BC: Library of Alexandria  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1879: _Modern Logic (Frege)_  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1884: U.S. Census (Hollerith)  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1941: _Model Theory (Tarski)_

#### 1950s

First generation.  
&nbsp;&nbsp;&nbsp; Batch processing.  
&nbsp;&nbsp;&nbsp; Sequential files and tapes  
&nbsp;&nbsp;&nbsp; Input on punched cards

#### 1960s

Second generation.  
&nbsp;&nbsp;&nbsp; Disk enabled random access files  
&nbsp;&nbsp;&nbsp; New access methods (ISAM, hash files)  
&nbsp;&nbsp;&nbsp; Mostly batch with some interactivity  
&nbsp;&nbsp;&nbsp; Independent applications with separate files  
&nbsp;&nbsp;&nbsp; Growing applications base

As application base grows, we got,  
&nbsp;&nbsp;&nbsp; Many shared files  
&nbsp;&nbsp;&nbsp; A multitude of file structures  
&nbsp;&nbsp;&nbsp; A need to exchange data among applications

A variety of problems,  
&nbsp;&nbsp;&nbsp; _Redundancy_: multiple copies  
&nbsp;&nbsp;&nbsp; _Inconsistency_: independent updates  
&nbsp;&nbsp;&nbsp; _Inaccuracy_: concurrent updates  
&nbsp;&nbsp;&nbsp; _Incompatibility_: multiple formats  
&nbsp;&nbsp;&nbsp; _Insecurity_: proliferation  
&nbsp;&nbsp;&nbsp; _Inauditability_: poor chain of responsibility  
&nbsp;&nbsp;&nbsp; _Inflexibility_: changes are difficult to apply

Hierarchial data model,

- IBM's Information Management System (IMS): concurrent access
- Only allow 1:N parent-child relationships (i.e. a tree)
- Hierarchy can be exploited for efficiency
- Queries navigate up and down trees - one record at a time
- Data access language embedded in business processing language
- Difficult to express some queries

Network data model,

- Charles Bachman's Integrated Data Store (IDS)
- Model standardized by Conference On Data Systems Languages (CODASYL)
- Data organized as collections of sets of records
- Separation of physical data representation from users' view of data
- Pointers between records represent relationships
- Set types encoded as lists
- Queries navigate between records - still one record at a time

#### 1970s

Edgar Codd proposes relational data model (1970), firm mathematical foundation $\rightarrow$ _declarative queries_.

Charles Bachman wins ACM Turing Award (1973), "The programmer as Navigator."

Peter Chen proposes E-R model (1976).

Transaction concepts (Jim Gray and others).

IBM's _System R_ and UC Berkeley's _Ingres_ systems demonstrate feasibility of relational DBMS (late 1970s).

#### 1980s

Development of commercial relational technology; IBM DB2, Oracle, Informix, Sybase.

Edgar Codd wins ACM Turning Award (1981).

SQL standarization efforts through ANSI and ISO.

Object-oriented DBMSs (late 1980s to middle of 1990s),  
&nbsp;&nbsp;&nbsp; Persistent objects  
&nbsp;&nbsp;&nbsp; Object IDs, methods, inheritance  
&nbsp;&nbsp;&nbsp; Navigational interface reminiscent of hierarchical model

#### 1990s - Present

Continued expansion of SQL and system capabilities.

New application areas includes,

- Internet
- Online Analytic Processing (OLAP)
- Data warehousing
- Embedded systems
- Multimedia
- XML
- Data streams

Jim Gray wins ACM Turing Award (1998).

Relational DBMSs incorporate objects (late 1990s).

Many new DBs in the industry (2000+).

Michael Stonebraker wins ACM Turing Award (2014).

### Summary

DBMS helps data management:

- Removes common code from applications
- Provides uniform access to data
- Guarantees data integrity
- Manages concurrent access
- Protects against system failure
- Sets access policies for data

## Lecture Relational Model, September 13, 2017

### The Relational Model

**Idea**  
All information is organized in (a finite number of) relations.

Features:

- Simple and clean data model
- Powerful and declarative query./update languages
- Semantic integrity constraints
- Data independence

### Relational Structures/Databases

Components:

- Universe
	- A set of values ${\bf D}$ with equality ($=$)
- Relation
	- Schema: name $R$, arity $k$ (the number of attributes)
	- Instance: a relation ${\bf R} \subseteq {\bf D}^{k}$
- Database
	- Schema: finite set of relation schemes
	- Instance: a relation ${\bf R}_{i}$ for each $R_{i}$

**Notation**  
Signature: $\rho = (R_{1}, ..., R_{n})$  
Instance: ${\bf D} = ({\bf D}, =, R_{i}, ..., R_{n})$

Relations are often called tables.

### Simple (Atomic) "Truths"

**Idea**  
Relationships between objects (tuples) that are present in an instance are true, absent relationships are false.

### Relational Calculus: Syntax

**Idea**  
Complex statements about truth can be formulated using the language of first-order logic.

**Defn.** (Syntax)  
Given a database schema $\rho = (R_{1}, ..., R_{k})$ and a set of variable names $\{x_{1}, x_{2}, ...\}$, formulas are defined by
$$
\varphi
::=
\underbrace{
	\underbrace{
		\underbrace{
			R_{i}(x_{i_{1}}, ..., x_{i_{k}})~|~x_{i} = x_{j}~|~\varphi \wedge \varphi~|~\exists x_{i}.\varphi
		}_{\text{conjunctive formulas}}~|~\varphi \vee \varphi
	}_{\text{positive formulas}}~|~\neg\varphi
}_{\text{first-order formulas}}
$$

#### First-order Variables and Valuations

A **valuation** is a function
$$\theta:~\{x_{1}, x_{2}, ...\} \rightarrow {\bf D}$$
that maps variable names to values in the universe.

**Idea**  
Ansers to queries $\Leftrightarrow$ valuations to free variables that make the formula true with respect to a database.

#### Complete Semantics

**Defn.**  
The _truth_ of formulas is defined with respect to

1. a _database instance_ ${\bf D} = ({\bf D}, =, {\bf R}, {\bf S}, ...)$, and
2. a _valuation_ $\theta:~\{x_{1}, x_{2}, ...\} \rightarrow {\bf D}$

as follows:

$$
\begin{aligned}
{\bf D}, \theta &\models R(x_{i_{1}}, ..., x_{i_{k}}) &\text{if } &R \in \rho,~(\theta(x_{i_{1}}), ..., \theta(x_{i_{k}})) \in {\bf R} \\
{\bf D}, \theta &\models x_{i} = x_{j} &\text{if } &\theta(x_{i}) = \theta(x_{j})\\
{\bf D}, \theta &\models \varphi \wedge \psi &\text{if } &{\bf D}, \theta \models \varphi \text{ and } {\bf D}, \theta \models \psi\\
{\bf D}, \theta &\models \neg\varphi &\text{if } &\text{not } {\bf D}, \theta \models \varphi \\
{\bf D}, \theta &\models \exists x_{i}.\varphi &\text{if } &{\bf D}, \theta[x_{i} \mapsto v] \models \varphi \text{ for some } v \in {\bf D}
\end{aligned}
$$

**Defn.**  
An answer to a query $\{(x_{1}, ..., x_{k}) | \varphi\}$ over $\bf D$ is a _relation_:
$$\{(\theta(x_{1}), ..., \theta(x_{k}))~|~{\bf D}, \theta \models \varphi\}$$
where $\{x_{1}, ..., x_{k}\} = FV(\varphi)$.

#### Equivalences and Syntactic Sugar

Boolean Equivalences (non-exhaustive)

- $\neg(\neg\varphi_{1}) \equiv \varphi_{1}$
- $\varphi_{1} \vee \varphi_{2} \equiv \neg(\neg\varphi_{1} \wedge \neg\varphi_{2})$
- $\varphi_{1} \rightarrow \varphi_{2} \equiv \neg\varphi_{1} \vee \varphi_{2}$
- $\varphi_{1} \leftrightarrow \varphi_{2} \equiv (\varphi_{1} \rightarrow \varphi_{2}) \wedge (\varphi_{2} \rightarrow \varphi_{1}) $

First-order Equivalences (non-exhaustive)

- $\forall x.\varphi \equiv \neg\exists x.\neg\varphi$

## Lecture September 18, 2017

### Laws a.k.a. Integrity Constraints

**Idea**  
_Integrity constraints_  
$~~\Rightarrow$ _yes/no queries_ that must be true in every valid database instance

- Addition is commutative
	- $\forall x,y,z\text{.PLUS}(x,y,z)\rightarrow\text{PLUS}(y,x,z)$
	- $\Rightarrow~(\neg\exists x,y,z\text{.PLUS}(x,y,z)\wedge\neg\text{PLUS}(y,x,z))$
- Addition is a (relational representation of a) binary function
	- $\forall x,y,z_{1},z_{2}\text{.PLUS}(x,y,z_{1})\wedge\text{PLUS}(x,y,z_{2})\rightarrow z_{1} = z_{2}$
	- $\Rightarrow~(\neg\exists x,y,z_{1},z_{2}\text{.PLUS}(x,y,z_{1})\wedge\text{PLUS}(x,y,z_{2})\wedge\neg(z_{1}=z_{2}))$
- Addition is a total function
	- $\forall x,y\text{.}\exists z\text{.PLUS}(x,y,z)$
- Addition is monotone in both arguments (harder), etc.

### Integrity Constraints

Relational _signature_ captures only the structure of relations.

**Idea**  
Valid database instances satisfy additional integrity constraints.

Values of a particular attribute belong to a prescribed _date type_.  
Values of attributes are unique among tuples in a relation (_keys_).  
Values appearing in one relation must also appear in another relation (_referential integrity_).  
Values cannot appear simultaneously in certain relations (_disjointness_).  
Values in certain relation must appear in at least one of another set of relations (_coverge_).

#### Views

**Idea**  
Answers to queries can be used to define derived relations (views) $\Rightarrow$ extension of a DB schema.

- Subtraction, complement, ...
- Collection-style publication, editor, ...

In general, a view is an integrity constraint of the form
$$\forall x_{1}, \ldots, x_{k}\text{.}R(x_{1}, \ldots, x_{k}) \leftrightarrow \varphi$$
for $R$ a new relation name and $x_{1}, \ldots, x_{k}$ free variables of $\varphi$.

#### Database Instances

**Defn.** (Database Schema)  
Let $\rho$ be a signature. A _database schema_ is a (finite) set of integrity constraints $\Sigma$ over $\rho$.

**Defn.**  
A database instance **D** (over a schema $\rho$) conforms to a schema $\Sigma$ (written **D** $\models \Sigma$) iff. **D**, $\theta \models \varphi$ for any integrity constraint $\varphi \in \Sigma$ and any valuation $\theta$.

#### So Far...

1. Databases $\Leftrightarrow$ relational structures
2. Queries $\Leftrightarrow$ set comprehensions with formulas in First-Order logic
3. Integrity constraints $\Leftrightarrow$ closed formulas in First-Order logic

Note: Database instances must be _finite_.

### Unsafe Queries

We only want queries with finite answers (over finite databases).

**Defn.** (Domain-independent Query)  
A query $\{(x_{1},\ldots,x_{k})~|~\varphi\}$ is _domain-independent_ if
$${\bf D_{1}}, \theta \models \varphi \Longleftrightarrow {\bf D_{2}}, \theta \models \varphi$$
for any pair of database instances ${\bf D_{1}} = (U_{1}, =, {\bf R_{1}},\ldots,{\bf R_{k}})$ and ${\bf D_{2}} = (U_{2}, =, {\bf R_{1}},\ldots,{\bf R_{k}})$ and all $\theta$.

---

**Thm**  
Answers to domain-independent queries contain only values that exist in ${\bf R_{1}}, \ldots, {\bf R_{k}}$ (the active domain).

---

Domain-independent + finite database $\Rightarrow$ "safe"

### Safety and Query Satisfiability

---

**Thm.**  
Satisfiability of first-order formulas is undecidable;

- co-r.e. in general
- r.e. for finite databases

**Proof**  
reduction from PCP (see Abiteboul _et. al._ book, p. 122-126).

---

**Thm.**  
Domain-independence of first-order queries is undecidable.

**Proof**  
$\varphi$ is satisfiable iff. $(x = y) \wedge \varphi$ is not domain-independent.

---

### Range-Restricted Queries

**Defn.** (Range restricted formulas)  
A formula $\varphi$ is _range restricted_ when, for $\varphi_{i}$ that are also range restricted, $\varphi$ has the form

$$
\begin{aligned}
&R(x_{i_{1}}, \ldots, x_{i_{k}}), \\
&\varphi_{1} \wedge \varphi_{2}, \\
&\varphi_{1} \wedge (x_{i} = x_{j}) &&(\{x_{i}, x_{j}\} \cap FV(\varphi_{1}) \neq \emptyset), \\
&\exists x_{i}.\varphi_{1} &&(x_{i} \in FV(\varphi_{1})), \\
&\varphi_{1} \vee \varphi_{2} &&(FV(\varphi_{1}) = FV(\varphi_{2})), \text{ or} \\
&\varphi_{1}\wedge\neg\varphi_{2} &&(FV(\varphi_{2}) \subseteq FV(\varphi_{1})).
\end{aligned}
$$

---

**Thm.**  
Range-restricted $\rightarrow$ Domain-independent.

---

### Domain Independence vs. Range-Restricted

---

**Thm.**  
Every domain-independent query can be written equivalently as a range restricted query.

**Proof.**

1. Restrict every variable in $\varphi$ to active domain,
2. Express the active domain using a unary query over the database instance.

---

### Computational Properties

- Evaluation of very query terminates
	- relational calculus is _not_ Turing complete
- **Data Complexity** in the size of the database, for a _fixed_ query.
	- In polynomial-time
	- In logarithmic-space
	- $\text{AC}_{0}$ (constant time on polynomially many CPUs in parallel)
- **Combined complexity**
	- In polynomial-space
	- Can express NP-hard problems (encode SAT)

### Query Evaluation vs. Theorem Proving

**Query Evaluation**  
Given a query $\{(x_{1}, \ldots, x_{k})~|~\varphi\}$ and a finite database instance **D** find all answers to the query.

**Query Satisfiability**  
Given a query $\{(x_{1}, \ldots, x_{k})~|~\varphi\}$ determine whether there is a (finite) database instance **D** for which the answer is non-empty.

- Much harder (undecidable) problem.
- Can be solved for fragments of the query language.

### Query Equivalence and DB Schema

**Defn.** (Query Subsumption)  
A query $\{(x_{1}, \ldots, x_{k})~|~\varphi\}$ _subsumes_ a query $\{(x_{1}, \ldots, x_{k})~|~\psi\}$ with respect to a database schema $\Sigma$ if
$$\{(\theta(x_{1}), \ldots, \theta(x_{k}))~|~{\bf D}, \theta \models \psi\} \subseteq \{(\theta(x_{1}), \ldots, \theta(x_{k}))~|~{\bf D}, \theta \models \varphi\}$$
for every database **D** such that **D** $\models \Sigma$.

- Necessary for query simplification
- Equivalent to proving $$\left(\bigwedge_{\phi_{i}\in\Sigma}\phi_{i} \right)\rightarrow(\forall x_{1}, \ldots, x_{k}.\varphi \rightarrow \psi$$
- Undecidable in general; decidable for fragments of relational calculus

### What Queries Cannot be Expressed in Relational Calculus

RC is _not_ Turing complete, there must be computable queries that cannot be written in RC.

- Built-in Operations
	- ordering, arithmetic, string operations, etc.
- Counting/Aggregation
	- cardinality of sets (parity)
- Reachability/Connectivity/...
	- paths in a graph (binary relation)
- Model extensions: Incompleteness/Inconsistency
	- tuples with _unknown_ (but existing) values
	- Incomplete relations and _open world assumption_
	- Conflicting information (e.g. from different data sources)

## Lecture September 20, 2017
