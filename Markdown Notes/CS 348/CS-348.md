# CS 348 - Introduction to Database Management

## IBM DB2 at UW

### First Steps

Available on `linux.student.cs.uwaterloo.ca`

- `ubuntu1604-002.student.cs.uwaterloo.ca`
- `ubuntu1604-006.student.cs.uwaterloo.ca`
- `ubuntu1804-008.student.cs.uwaterloo.ca`

Set up environment correctly:

sh, bash. et al:  
`source ~db2inst2/sqllib/db2profile`

csh, tcsh, et al:  
`source ~db2inst2/sqllib/db2cshrc`

## Lecture _September 11, 2017_

### Topics

1. Why do we use databases?
	- Functionality provided by a Database Management System
2. How do we use a Database Management System?
	- Relational model
	- Foundational query languages and SQL
	- Transactions, concurrency, and recovery
3. How do we design a database?
	- Entity-Relationship (ER) modelling
	- Accommodating and enforcing constraints

### What is "Data"

- ANSI definition,
	- _facts_, _concepts_, or _instructions_ in a formalized manner suitable for humans or by automatic means
	- _meaning_

### Early Data Management - Ancient History

Data are not stored on disk.  
One data set per program. High data redundancy.  
See written notes for diagram.

### File Processing - More Recent History

Data are stored in files with interface between programs and files.  
Various access methods exist (e.g., sequential, indexed, random).  
One file corresponds to one or several programs.  
See written notes for diagram.

### Database Approach

See written notes for diagrams.

### What is a Database

**Database**  
A _large_ and _persistent_ collection of (more-or-less similar) pieces of
information organized in a way that facilitates efficient _retrieval_ and
_modification_.  
=> structure of the _database_ is determined by a **data model**.

Examples:

- a file cabinet
- a library system
- a personnel management system

**Database Management System (DBMS)**  
A program (or set of programs) that manages details related to storage
and access for a database.

### Database Management System

**Idea**  
Abstract common functions and creates a uniform well defined interface for applications accessing data.

1. Data Model, all data stored in a well defined way
2. Access control, only authorized people get to see/modify it
3. Concurrency control, multiple concurrent applications access data
4. Database recovery, nothing gets accidentally lost
5. Database maintenance

### Schema and Instance

A **schema** is a description of the data interface to the database. i.e. _how the data is organized_.

A **database instance** is a database (real data) that conforms to a given schema.  
A schema can (_and typically does_) have many instances.

### Applications of Databases

Original:

- Inventory control
- Payroll
- Banking and financial systems
- Reservation systems

More recent:

- Computer aided design (CAD)
- Software development (CASE, SDE/SFE)
- Telecommunication systems
- E-commerce
- Dynamic/Personalized web content

### Why Database Technology

Data constitute an organization asset $\Rightarrow$ _integrated control_.  
&nbsp;&nbsp;&nbsp; Reduction of redundancy  
&nbsp;&nbsp;&nbsp; Avoidance of inconsistency  
&nbsp;&nbsp;&nbsp; Data integrity  
&nbsp;&nbsp;&nbsp; Shareability  
&nbsp;&nbsp;&nbsp; Improved security

Programmer productivity $\Rightarrow$ _data independence_.  
&nbsp;&nbsp;&nbsp; Programmers do not have to deal with data organization.

### Three Level Schema Architecture

1. _External schema (view)_

	What the application programs and user see; may differ for different users of the same database.

2. _Conceptual schema_

	Description of the logical structure of _all_ data in the database.

3. _Physical schema_

	Description of physical aspects (selection of files, devices, storage algorithms, etc.)

### Data Independence

**Idea**  
Applications do not access data directly but, rather through an abstract data model provided by the DBMS.

Two kinds of data independence:  
_Physical_: applications immune to changes in storage structures.  
_Logical_: applications immune to changes in data organization.

_Note_: one of the most important reason to use a DBMS.

### Transaction

When multiple applications access the same data, undesirable results occur.

**Idea**  
Every application may think it is the sole application accessing the data.  
The DBMS should guarantee correct execution.

A **transaction**, is then, an application-specific atomic and durable unit of work.

Properties of transactions:

- _Atomic_: a transaction occurs entirely, or not at all
- _Consistency_: each transaction preserves the consistency of the database
- _Isolated_: concurrent transactions do not interfere with each other
- _Durable_: a transaction's changes are permanent once completed

### Interfacing to the DBMS

**Data Definition Language** (**DDL**): for specifying schemas,  
&nbsp;&nbsp;&nbsp; May have different DDLs for external schema, conceptual schema, internal schema
&nbsp;&nbsp;&nbsp; Information is stored in the **data dictionary**, or **catalog**

**Data Manipulation Language** (**DML**): for specifying queries and updates,  
&nbsp;&nbsp;&nbsp; **navigational** (procedural)  
&nbsp;&nbsp;&nbsp; **non-navigational** (declarative)

### Types of Database Users

- End User
	- Accesses DB indirectly through forms or other query-generating applications, or
	- Generates ad-hoc queries using the DML
- Application developer
	- Designs and implements applications that accesses the database
- Database administrator (DBA)
	- Manages conceptual schema
	- Assists with application view integration
	- Monitors and tunes DBMS performance

### Brief History of Data Management

#### Ancient

2000 BC: Sumerian Records  
&nbsp; 350 BC: _Syllogisms (Aristotle)_  
&nbsp; 296 BC: Library of Alexandria  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1879: _Modern Logic (Frege)_  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1884: U.S. Census (Hollerith)  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1941: _Model Theory (Tarski)_

#### 1950s

First generation.  
&nbsp;&nbsp;&nbsp; Batch processing.  
&nbsp;&nbsp;&nbsp; Sequential files and tapes  
&nbsp;&nbsp;&nbsp; Input on punched cards

#### 1960s

Second generation.  
&nbsp;&nbsp;&nbsp; Disk enabled random access files  
&nbsp;&nbsp;&nbsp; New access methods (ISAM, hash files)  
&nbsp;&nbsp;&nbsp; Mostly batch with some interactivity  
&nbsp;&nbsp;&nbsp; Independent applications with separate files  
&nbsp;&nbsp;&nbsp; Growing applications base

As application base grows, we got,  
&nbsp;&nbsp;&nbsp; Many shared files  
&nbsp;&nbsp;&nbsp; A multitude of file structures  
&nbsp;&nbsp;&nbsp; A need to exchange data among applications

A variety of problems,  
&nbsp;&nbsp;&nbsp; _Redundancy_: multiple copies  
&nbsp;&nbsp;&nbsp; _Inconsistency_: independent updates  
&nbsp;&nbsp;&nbsp; _Inaccuracy_: concurrent updates  
&nbsp;&nbsp;&nbsp; _Incompatibility_: multiple formats  
&nbsp;&nbsp;&nbsp; _Insecurity_: proliferation  
&nbsp;&nbsp;&nbsp; _Inauditability_: poor chain of responsibility  
&nbsp;&nbsp;&nbsp; _Inflexibility_: changes are difficult to apply

Hierarchial data model,

- IBM's Information Management System (IMS): concurrent access
- Only allow 1:N parent-child relationships (i.e. a tree)
- Hierarchy can be exploited for efficiency
- Queries navigate up and down trees - one record at a time
- Data access language embedded in business processing language
- Difficult to express some queries

Network data model,

- Charles Bachman's Integrated Data Store (IDS)
- Model standardized by Conference On Data Systems Languages (CODASYL)
- Data organized as collections of sets of records
- Separation of physical data representation from users' view of data
- Pointers between records represent relationships
- Set types encoded as lists
- Queries navigate between records - still one record at a time

#### 1970s

Edgar Codd proposes relational data model (1970), firm mathematical foundation $\rightarrow$ _declarative queries_.

Charles Bachman wins ACM Turing Award (1973), "The programmer as Navigator."

Peter Chen proposes E-R model (1976).

Transaction concepts (Jim Gray and others).

IBM's _System R_ and UC Berkeley's _Ingres_ systems demonstrate feasibility of relational DBMS (late 1970s).

#### 1980s

Development of commercial relational technology; IBM DB2, Oracle, Informix, Sybase.

Edgar Codd wins ACM Turning Award (1981).

SQL standarization efforts through ANSI and ISO.

Object-oriented DBMSs (late 1980s to middle of 1990s),  
&nbsp;&nbsp;&nbsp; Persistent objects  
&nbsp;&nbsp;&nbsp; Object IDs, methods, inheritance  
&nbsp;&nbsp;&nbsp; Navigational interface reminiscent of hierarchical model

#### 1990s - Present

Continued expansion of SQL and system capabilities.

New application areas includes,

- Internet
- Online Analytic Processing (OLAP)
- Data warehousing
- Embedded systems
- Multimedia
- XML
- Data streams

Jim Gray wins ACM Turing Award (1998).

Relational DBMSs incorporate objects (late 1990s).

Many new DBs in the industry (2000+).

Michael Stonebraker wins ACM Turing Award (2014).

### Summary

DBMS helps data management:

- Removes common code from applications
- Provides uniform access to data
- Guarantees data integrity
- Manages concurrent access
- Protects against system failure
- Sets access policies for data

## Lecture Relational Model, _September 13, 2017_

### The Relational Model

**Idea**  
All information is organized in (a finite number of) relations.

Features:

- Simple and clean data model
- Powerful and declarative query./update languages
- Semantic integrity constraints
- Data independence

### Relational Structures/Databases

Components:

- Universe
	- A set of values ${\bf D}$ with equality ($=$)
- Relation
	- Schema: name $R$, arity $k$ (the number of attributes)
	- Instance: a relation ${\bf R} \subseteq {\bf D}^{k}$
- Database
	- Schema: finite set of relation schemes
	- Instance: a relation ${\bf R}_{i}$ for each $R_{i}$

**Notation**  
Signature: $\rho = (R_{1}, ..., R_{n})$  
Instance: ${\bf D} = ({\bf D}, =, R_{i}, ..., R_{n})$

Relations are often called tables.

### Simple (Atomic) "Truths"

**Idea**  
Relationships between objects (tuples) that are present in an instance are true, absent relationships are false.

### Relational Calculus: Syntax

**Idea**  
Complex statements about truth can be formulated using the language of first-order logic.

**Defn.** (Syntax)  
Given a database schema $\rho = (R_{1}, ..., R_{k})$ and a set of variable names $\{x_{1}, x_{2}, ...\}$, formulas are defined by
$$
\varphi
::=
\underbrace{
	\underbrace{
		\underbrace{
			R_{i}(x_{i_{1}}, ..., x_{i_{k}})~|~x_{i} = x_{j}~|~\varphi \wedge \varphi~|~\exists x_{i}.\varphi
		}_{\text{conjunctive formulas}}~|~\varphi \vee \varphi
	}_{\text{positive formulas}}~|~\neg\varphi
}_{\text{first-order formulas}}
$$

#### First-order Variables and Valuations

A **valuation** is a function
$$\theta:~\{x_{1}, x_{2}, ...\} \rightarrow {\bf D}$$
that maps variable names to values in the universe.

**Idea**  
Ansers to queries $\Leftrightarrow$ valuations to free variables that make the formula true with respect to a database.

#### Complete Semantics

**Defn.**  
The _truth_ of formulas is defined with respect to

1. a _database instance_ ${\bf D} = ({\bf D}, =, {\bf R}, {\bf S}, ...)$, and
2. a _valuation_ $\theta:~\{x_{1}, x_{2}, ...\} \rightarrow {\bf D}$

as follows:

$$
\begin{aligned}
{\bf D}, \theta &\models R(x_{i_{1}}, ..., x_{i_{k}}) &\text{if } &R \in \rho,~(\theta(x_{i_{1}}), ..., \theta(x_{i_{k}})) \in {\bf R} \\
{\bf D}, \theta &\models x_{i} = x_{j} &\text{if } &\theta(x_{i}) = \theta(x_{j})\\
{\bf D}, \theta &\models \varphi \wedge \psi &\text{if } &{\bf D}, \theta \models \varphi \text{ and } {\bf D}, \theta \models \psi\\
{\bf D}, \theta &\models \neg\varphi &\text{if } &\text{not } {\bf D}, \theta \models \varphi \\
{\bf D}, \theta &\models \exists x_{i}.\varphi &\text{if } &{\bf D}, \theta[x_{i} \mapsto v] \models \varphi \text{ for some } v \in {\bf D}
\end{aligned}
$$

**Defn.**  
An answer to a query $\{(x_{1}, ..., x_{k}) | \varphi\}$ over $\bf D$ is a _relation_:
$$\{(\theta(x_{1}), ..., \theta(x_{k}))~|~{\bf D}, \theta \models \varphi\}$$
where $\{x_{1}, ..., x_{k}\} = FV(\varphi)$.

#### Equivalences and Syntactic Sugar

Boolean Equivalences (non-exhaustive)

- $\neg(\neg\varphi_{1}) \equiv \varphi_{1}$
- $\varphi_{1} \vee \varphi_{2} \equiv \neg(\neg\varphi_{1} \wedge \neg\varphi_{2})$
- $\varphi_{1} \rightarrow \varphi_{2} \equiv \neg\varphi_{1} \vee \varphi_{2}$
- $\varphi_{1} \leftrightarrow \varphi_{2} \equiv (\varphi_{1} \rightarrow \varphi_{2}) \wedge (\varphi_{2} \rightarrow \varphi_{1}) $

First-order Equivalences (non-exhaustive)

- $\forall x.\varphi \equiv \neg\exists x.\neg\varphi$

## Lecture September 18, 2017

### Laws a.k.a. Integrity Constraints

**Idea**  
_Integrity constraints_  
$~~\Rightarrow$ _yes/no queries_ that must be true in every valid database instance

- Addition is commutative
	- $\forall x,y,z\text{.PLUS}(x,y,z)\rightarrow\text{PLUS}(y,x,z)$
	- $\Rightarrow~(\neg\exists x,y,z\text{.PLUS}(x,y,z)\wedge\neg\text{PLUS}(y,x,z))$
- Addition is a (relational representation of a) binary function
	- $\forall x,y,z_{1},z_{2}\text{.PLUS}(x,y,z_{1})\wedge\text{PLUS}(x,y,z_{2})\rightarrow z_{1} = z_{2}$
	- $\Rightarrow~(\neg\exists x,y,z_{1},z_{2}\text{.PLUS}(x,y,z_{1})\wedge\text{PLUS}(x,y,z_{2})\wedge\neg(z_{1}=z_{2}))$
- Addition is a total function
	- $\forall x,y\text{.}\exists z\text{.PLUS}(x,y,z)$
- Addition is monotone in both arguments (harder), etc.

### Integrity Constraints

Relational _signature_ captures only the structure of relations.

**Idea**  
Valid database instances satisfy additional integrity constraints.

Values of a particular attribute belong to a prescribed _date type_.  
Values of attributes are unique among tuples in a relation (_keys_).  
Values appearing in one relation must also appear in another relation (_referential integrity_).  
Values cannot appear simultaneously in certain relations (_disjointness_).  
Values in certain relation must appear in at least one of another set of relations (_coverge_).

#### Views

**Idea**  
Answers to queries can be used to define derived relations (views) $\Rightarrow$ extension of a DB schema.

- Subtraction, complement, ...
- Collection-style publication, editor, ...

In general, a view is an integrity constraint of the form
$$\forall x_{1}, \ldots, x_{k}\text{.}R(x_{1}, \ldots, x_{k}) \leftrightarrow \varphi$$
for $R$ a new relation name and $x_{1}, \ldots, x_{k}$ free variables of $\varphi$.

#### Database Instances

**Defn.** (Database Schema)  
Let $\rho$ be a signature. A _database schema_ is a (finite) set of integrity constraints $\Sigma$ over $\rho$.

**Defn.**  
A database instance **D** (over a schema $\rho$) conforms to a schema $\Sigma$ (written **D** $\models \Sigma$) iff. **D**, $\theta \models \varphi$ for any integrity constraint $\varphi \in \Sigma$ and any valuation $\theta$.

#### So Far...

1. Databases $\Leftrightarrow$ relational structures
2. Queries $\Leftrightarrow$ set comprehensions with formulas in First-Order logic
3. Integrity constraints $\Leftrightarrow$ closed formulas in First-Order logic

Note: Database instances must be _finite_.

### Unsafe Queries

We only want queries with finite answers (over finite databases).

**Defn.** (Domain-independent Query)  
A query $\{(x_{1},\ldots,x_{k})~|~\varphi\}$ is _domain-independent_ if
$${\bf D_{1}}, \theta \models \varphi \Longleftrightarrow {\bf D_{2}}, \theta \models \varphi$$
for any pair of database instances ${\bf D_{1}} = (U_{1}, =, {\bf R_{1}},\ldots,{\bf R_{k}})$ and ${\bf D_{2}} = (U_{2}, =, {\bf R_{1}},\ldots,{\bf R_{k}})$ and all $\theta$.

---

**Thm**  
Answers to domain-independent queries contain only values that exist in ${\bf R_{1}}, \ldots, {\bf R_{k}}$ (the active domain).

---

Domain-independent + finite database $\Rightarrow$ "safe"

### Safety and Query Satisfiability

---

**Thm.**  
Satisfiability of first-order formulas is undecidable;

- co-r.e. in general
- r.e. for finite databases

**Proof**  
reduction from PCP (see Abiteboul _et. al._ book, p. 122-126).

---

**Thm.**  
Domain-independence of first-order queries is undecidable.

**Proof**  
$\varphi$ is satisfiable iff. $(x = y) \wedge \varphi$ is not domain-independent.

---

### Range-Restricted Queries

**Defn.** (Range restricted formulas)  
A formula $\varphi$ is _range restricted_ when, for $\varphi_{i}$ that are also range restricted, $\varphi$ has the form

$$
\begin{aligned}
&R(x_{i_{1}}, \ldots, x_{i_{k}}), \\
&\varphi_{1} \wedge \varphi_{2}, \\
&\varphi_{1} \wedge (x_{i} = x_{j}) &&(\{x_{i}, x_{j}\} \cap FV(\varphi_{1}) \neq \emptyset), \\
&\exists x_{i}.\varphi_{1} &&(x_{i} \in FV(\varphi_{1})), \\
&\varphi_{1} \vee \varphi_{2} &&(FV(\varphi_{1}) = FV(\varphi_{2})), \text{ or} \\
&\varphi_{1}\wedge\neg\varphi_{2} &&(FV(\varphi_{2}) \subseteq FV(\varphi_{1})).
\end{aligned}
$$

---

**Thm.**  
Range-restricted $\rightarrow$ Domain-independent.

---

### Domain Independence vs. Range-Restricted

---

**Thm.**  
Every domain-independent query can be written equivalently as a range restricted query.

**Proof.**

1. Restrict every variable in $\varphi$ to active domain,
2. Express the active domain using a unary query over the database instance.

---

### Computational Properties

- Evaluation of very query terminates
	- relational calculus is _not_ Turing complete
- **Data Complexity** in the size of the database, for a _fixed_ query.
	- In polynomial-time
	- In logarithmic-space
	- $\text{AC}_{0}$ (constant time on polynomially many CPUs in parallel)
- **Combined complexity**
	- In polynomial-space
	- Can express NP-hard problems (encode SAT)

### Query Evaluation vs. Theorem Proving

**Query Evaluation**  
Given a query $\{(x_{1}, \ldots, x_{k})~|~\varphi\}$ and a finite database instance **D** find all answers to the query.

**Query Satisfiability**  
Given a query $\{(x_{1}, \ldots, x_{k})~|~\varphi\}$ determine whether there is a (finite) database instance **D** for which the answer is non-empty.

- Much harder (undecidable) problem.
- Can be solved for fragments of the query language.

### Query Equivalence and DB Schema

**Defn.** (Query Subsumption)  
A query $\{(x_{1}, \ldots, x_{k})~|~\varphi\}$ _subsumes_ a query $\{(x_{1}, \ldots, x_{k})~|~\psi\}$ with respect to a database schema $\Sigma$ if
$$\{(\theta(x_{1}), \ldots, \theta(x_{k}))~|~{\bf D}, \theta \models \psi\} \subseteq \{(\theta(x_{1}), \ldots, \theta(x_{k}))~|~{\bf D}, \theta \models \varphi\}$$
for every database **D** such that **D** $\models \Sigma$.

- Necessary for query simplification
- Equivalent to proving $$\left(\bigwedge_{\phi_{i}\in\Sigma}\phi_{i} \right)\rightarrow(\forall x_{1}, \ldots, x_{k}.\varphi \rightarrow \psi$$
- Undecidable in general; decidable for fragments of relational calculus

### What Queries Cannot be Expressed in Relational Calculus

RC is _not_ Turing complete, there must be computable queries that cannot be written in RC.

- Built-in Operations
	- ordering, arithmetic, string operations, etc.
- Counting/Aggregation
	- cardinality of sets (parity)
- Reachability/Connectivity/...
	- paths in a graph (binary relation)
- Model extensions: Incompleteness/Inconsistency
	- tuples with _unknown_ (but existing) values
	- Incomplete relations and _open world assumption_
	- Conflicting information (e.g. from different data sources)

## Lecture SQL, _September 20, 2017_

Based on _Relational Calculus_,

- Conjunctive queries, e.g. `SELECT` blocks
- Set operations
- Update language
- Non first-order features

BAG (multi-set) semantics.

NULL values (avoid if at all possible).

A _committee_ design,

- Often more _pragmatic_ than logical
- Evolving _standard_: SQL-89, SQL-92, SQL-1999, SQL:2003/2006/2008/2011/2016

Three major components:

1. Data Manipulation Language (DML)
	- Query language
	- Update language
	- Also embedded SQL (SQL/J) and ODBC (JDBC); necessary for app dev
2. Data Definition Language (DDL)
	- Defines schema for relations
	- Creates (modifies or destroys) database objects
3. Data Control Language (DCL)
	- Access control

Note: SQL is **_NOT_** case sensitive.

### SQL Data Types

| | |
|---|---|
| `integer` | integer (32 bits) |
| `smallint` | integer (16 bits) |
| `decimal(m, n)` | fixed decimal |
| `float` | IEEE float (32 bits) |
| `char(n)` | character string (length $n$) |
| `varchar(n)` | variable length string (at most $n$) |
| `date` | year/month/day |
| `time` | hh:mm:ss.ss |

Sample database in written notes.

### The Basic `SELECT` Block

Basic syntax:

```sql
SELECT DISTINCT results
FROM            tables
WHERE           conditions
```

Allows formulation of conjunctive ($\exists, \wedge$) queries of the form
$$\left\{\text{results}~|~\exists\text{unused}.\left(\bigwedge\text{tables}\right)\wedge\text{conditions}\right\}$$

- A conjunction of _tables_ with _conditions_
- _results_ specifies values in the resulting tuples, and
- _unused_ are variables not used in _results_

**Example**  
List all authors in the database:

```sql {.line-numbers}
select distinct *
from author;
```

### Variables vs. Attributes

Relational Calculus uses _positional_ notation

- No need for _attribute_ names
- Inconvenient for relations with high arity

SQL uses _co-relations_ (tuple variables) and _attribute names_ to assign default variable names to components of tuples,  
$R\text{[AS]}p$ in SQL stands for $R(p.a_{1}, \ldots, p,a_{n})$ in RC where $a_{1}, \ldots, a_{n}$ are the _attribute names_ declared for $R$.

**Example**  
LIst all publications with at least two authors,
$$\{p~|~\exists a_{1}, a_{2}.\text{wrote}(a_{1},p)\wedge\text{wrote}(a_{2},p)\wedge a_{1} \neq a_{2}\}$$

```sql {.line-numbers}
select distinct r1.publication
from wrote r1, wrote r2
where r1.publication = r2.publication
  and r1.author != r2.author;
```

Cannot _share_ a variable ($p$) in the two `wrote` relations, need for explicit equality `r1.publication = r2.publication`.

**Example**  
List titles of all books,
$$\{t~|~\exists p,b,y.\text{publication}(p, t)\wedge\text{book}(p, b, y)\}$$

```sql {.line-numbers}
select distinct title
from publication, book
where publication.pubid = book.pubid;
```

Relations can serve as their own _co-relations_ when _unambiguous_.

### The `FROM` Clause Summary

Syntax:
$$\texttt{FROM}~R_{1}[[\texttt{AS}]n_{1}], \ldots, R_{k}[[\texttt{AS}]n_{k}]$$

- $R_{i}$ are relation (table) names.  
- $n_{i}$ are distinct identifiers.
- The clause represents a _conjunction_ $R_{1}\wedge\ldots\wedge R_{k}$
	- All variables of $R_{i}$'s are _distinct_
	- We use (co-)relation names to resolve ambiguities
- Can NOT appear alone, only as part of the `select` block

### The `SELECT` Clause

Syntax:
$$\texttt{SELECT DISTINCT}~e_{1} [[\texttt{AS}]n_{1}],\ldots,e_{k}[[\texttt{AS}]n_{k}]$$

- Eliminate superfluous attributes from answers ($\exists$)
- Form _expressions_,
	- built-in functions applied to values of attributes
- Give names to attributes in the answer

### Standard Expressions

We can _create_ values in the answer tuples using _built-in_ functions:

- On numeric types
	- $+, -, *, /, \ldots~\text{(usual arithmetic)}$
- On strings
	- $||\text{ (concatenation)}, \texttt{substr}, \ldots$
- Constants (of appropriate types)
	- `SELECT 1` is a valid query in SQL-92
- User defined functions (UDF)

_Note_: all attribute names MUST be "present" in the `FROM` clause.

**Example**  
For every article list the number of pages:

```sql {.line-numbers}
select distinct pubid, endpage - startpage + 1
from article;
```

#### Naming Attributes in the Results

Results of queries $\Leftrightarrow$ Tables.

What are the names of attributes in the result of a `SELECT` clause?

- A single attribute: inherits the name
- An expression: implementation dependent

We can--and should--_explicitly_ name the resulting attributes.

### The `WHERE` Clause

Additional _conditions_ on tuples that qualify for the answer,
$$\texttt{WHERE } {\bf C}$$

Standard atomic conditions:

1. Equality: =, != (on all types)
2. Order: < , <=, >, >=, <> (on numeric and string types)

Conditions may involve expressions, similar conditions as in the `SELECT` clause.

**Example**  
Find all articles with more than 20 pages,

```sql {.line-numbers}
select *
from article
where endpage - startpage > 20;
```

#### Boolean Connectives

Atomic conditions can be combined using _boolean connectives_:

- `AND` (conjunction)
- `OR` (disjunction)
- `NOT` (negation)

### SQL Select Block Summary

- Simple `SELECT` block accounts for many queries
	- All in $\exists, \wedge$ fragment of relational calculus.
- Additional features
	- Alternative names for relations
	- Expressions and naming in the output
	- Built-in atomic predicates and boolean connectives

### Set Operations at Glance

Answers to `SELECT` blocks are _relations_ (sets of tuples), so we can apply _set operations_ on them:

- Set union: $Q_{1}~\texttt{UNION}~Q_{2}$
	- The set of tuples in $Q_{1}$ or in $Q_{2}$
	- Used to express `or`  
- Set difference: $Q_{1}~\texttt{EXCEPT}~Q_{2}$
	- The set of tuples in $Q_{1}$, but not in $Q_{2}$
	- Used to express `and not`  
- Set intersection: $Q_{1}~\texttt{INTERSECT}~Q_{2}$
	- The set of tuples in both $Q_{1}$ and $Q_{2}$
	- Used to express `and`

$Q_{1}$ and $Q_{2}$ must have _union-compatible_ signatures, same number and types of attributes.

**Example** (Set Union)

```sql {.line-numbers}
(select distinct pubid from book)
union
(select distinct pubid from journal);
```

**Example** (Set Difference)

```sql {.line-numbers}
(select distinct pubid from publication)
except
(select distinct pubid from article);
```

## Lecture September 25, 2017

### Nesting of Queries, Naming (Sub-)Queries

**Idea**  
Queries denotes _relations_, assign names to (results of) queries.  
Can be used later in place of (base) relations.

Syntax,

```sql {.line-numbers}
with foo1 [opt-schema-1]
	as ( query-1-goes-here ),
	...
	foon [opt-schema-n]
	as ( query-n-goes-here )
query-that-uses-foo1-...-foon-as-table-names
```

**Example**

```sql {.line-numbers}
with bookorjournal as
	( (select distinct pubid from book)
		union
		(select distinct pubid from journal)
	)
select distinct title
from publication, bookorjournal
where publication.pubid = bookorjournal.pubid
```

### `FROM` Clause Revisited

Using `WITH` can be cumbersome $\rightarrow$ don't want to name every sub-expression.

SQL-92 allows _inline_ queries in the `FROM` clause,

```sql
FROM ..., ( query-here ) id, ...
```

`id` stands for the result of `query-here`  
`id` is _mandatory_.

Note: does not work in "old" SQL (SQL-89); views were the only option.

**Example**

```sql {.line-numbers}
select distinct title
from publication,
	( (select distinct pubid from journal)
		union
		(select distinct pubid from book)
	) jb
where publication.pubid = jb.pubid
```

### Why not use `OR` instead of `UNION`

A _common_ mistake is to use `OR` in the `WHERE` clause instead of the `UNION` operator.

An incorrect solution:

```sql {.line-numbers}
select title
from publication, book, journal
where publication.pubid = book.pubid
	or publication.pubid = journal.pubid
```

Often works but what if there are no `book`s? Or if there are no `journal`s.

### Summary on First-Order SQL

SQL introduced so far captures all of _Relational Calculus_.

- Optionally with duplicate semantics
- Powerful (many queries can be expressed)
- Efficient (PTIME, LOGSPACE)

Shortcomings:

- Some queries are hard to write (syntax sugar)
- No "counting" (aggregation)
- No "path in graph" (recursion)

### `WHERE` Sub-Queries

Additional (complex) search conditions, $\Rightarrow$ query-based search predicates.

Advantage is it simplifies writing queries with negation.

Drawbacks:

- Complicated semantics, especially when duplicates are involved
- _Very_ easy to make mistakes

_Very commonly_ used to formulate queries.

#### Overview

Presence/Absence of a single value in a query  
`Attr IN ( Q )`{.sql}  
`Attr NOT IN ( Q )`{.sql}

Relationship of a value to some/all values in a query  
`Attr op SOME ( Q )`{.sql}  
`Attr op ALL ( Q )`{.sql}

Emptiness/Non-emptiness of a query  
`EXISTS ( Q )`{.sql}  
`NOT EXISTS ( Q )`{.sql}

**Example** (`Attr IN ( Q )`{.sql})

```sql {.line-numbers}
select distinct title
from publication
where pubid in (
	select pubid from article
)
```

**Example** (`Attr NOT IN ( Q )`{.sql})

```sql {.line-numbers}
select *
from wrote
where publication not in (
	(select pubid from book)
	union
	(select pubid from journal)
)
```

Alternatively,

```sql {.line-numbers}
select *
from wrote
where publication not in (
	select pubid from book
) and publication not in (
	select pubid from journal
)
```

**Example** (`Attr op SOME/ALL ( Q )`{.sql})

```sql {.line-numbers}
select distinct pubid
from article
where endpage-startpage >= all {
	select endpage-startpage
	from article
}
```

Another way of saying `max`.

`attr = SOME (Q)`{.sql} is the same as `attr IN (Q)`{.sql}.  
`attr <> ALL (Q)`{.sql} is the same as `attr NOT IN (Q)`{.sql}.

### Parametric Subqueries

SQL allows _parametric_ (correlated) subqueries, of the form $Q(p_{1}, \ldots, p_{k})$ where $p_{i}$ are attributes in the main query.  
The _truth_ of a predicate defined by a subquery is determined for each substittuion (tuple) in the main query,

1. instantiate all the paramters and
2. check for the truth value as before.

**Example** (`EXISTS`{.sql})

```sql {.line-numbers}
select *
from wrote r
where exists (
	select *
	from wrote s
	where r.publication = s.publication
		and r.author <> s.author
)
```

**Example** (`NOT EXISTS`{.sql})

```sql {.line-numbers}
select *
from wrote r
where not exists (
	select *
	from wrote s
	where r.publication = s.publication
		and r.author <> s.author
)
```

**Example** (`IN`{.sql})

```sql {.line-numbers}
select *
from wrote r
where publication in (
	select publication
	from wrote s
	where r.author <> s.author
)
```

#### More Levels of Nesting

`WHERE` subqueries are _just_ queries,

- We can nest again and again and...
- Every nested subquery can use attributes from the enclosing queries as paramters
- Correct naming is imperative

This is used to formulate very complexx search conditions, attributes present in the subquery only _cannot_ be used to construct the result(s)!

**Example**  
List all authors who always publish with someone else:

```sql {.line-numbers}
select distinct a1.name
from author a1, author a2
where not exists (
	select *
	from publication p, wrote w1
	where p.publication = w1.publication
		and a1.aid = w1.author
		and a2.aid not in (
			select author
			from wrote
			where publication = p.pubid
				and author <> a1.aid
		)
)
```

Relation calculus equivalent:
$$\{n~|~\exists a_{1},a_{2},m\text{.author}(a_{1},n)\wedge\text{author}(a_{2},m)\wedge a_{1}\neq a_{2}\wedge\forall p~\text{wrote}(a_{1},p)\rightarrow\text{wrote}(a_{2}, p)\}$$

#### `WHERE` Subqueries Summary

`WHERE` subqueries--easy formulationof queries of the form "All x in R such that (a part of) x doesn't appear in S".  
Subqueries only stand for `WHERE` conditions, it cannot be used to produce results.  
We could use _input parameters_ but these must be _bound_ in the main query.

### Modifing a Database

Naive approach (not acceptable in practice):
$$\begin{aligned}&\texttt{DBSTART;}\\&r_{1}:=Q_{1}(DB);\\&\ldots\\&r_{k}:=Q_{k}(DB);\\&\texttt{DBCOMMIT;}\end{aligned}$$

#### Incremental Updates

**Idea**  
Tables are large but _updates are small_ $\Rightarrow$ incremental updates.

1. Insertion of a tuple (`INSERT`)
	- Constant tuple
	- Results of queries
2. Deleteion of tuples (`DELETE`)
	- Based on match of a condition
3. Modification of tuples (`UPDATE`)
	- Allows updating "in place"
	- Based on match of a condition

#### SQL Insert

One constant tuple (or a fixed number):

```sql
INSERT INTO r[(a1,...,ak)]
	VALUES (v1,...,vk)
```

Adds tuples $(v_{1},\ldots,v_{k})$ to $r$.  
The type of $(v_{1},\ldots,v_{k})$ must match the schema definition of $r$.

Multiple tuples (generated by a query):

```sql
INSERT INTO r ( Q )
```

Adds result of $Q$ to $r$.

**Example** (Insertion of a tuple)  
Add a new author:

```sql {.line-numbers}
insert into author
	values (4, 'Niwinski, Damian', 'zls.mimuw.edu.pl/~niwinski');
```

**Example** (Use of a query)  
Add a new author without looking up author id:

```sql {.line-numbers}
insert into author (
	select max(aid)+1, 'Snodgrass, Richard T', 'www.cs.arizona.edu/people/rts'
	from author
);
```

#### SQL Delete

Deletion using a condition:

```sql
DELETE FROM r
WHERE cond
```

Deletes _all_ tuples that match `cond`.

Deletion using cursors (later), available in embedded SQL. It's the only way to delete ont out of two duplicate tuples.

**Example**  
Delete all publications that are not articles or the collections an article appears in:

```sql {.line-numbers}
delete from publication
where pubid not in (
	select pubid
	from article
) and pubid not in (
	select crossref
	from article
);
```

#### SQL Update

Two components:

1. An update statement (`SET`), an assignment of values to attributes
2. A search condition (`WHERE`)

Syntax:

```sql
UPDATE r
SET update_statement
WHERE condition
```

**Example**  
Update the url of authors whose names start with "Toman":

```sql {.line-numbers}
update author
set url = 'bricks.dk/~david'
where aid in (
	select aid
	from author
	where name like 'Toman%'
);
```

## Lecture September 27, 2017

### Support for Transactions

The DBMS guarantees noninterference (serializability) of all data access requests to tables in a database instance.

Transaction starts with first _access_ of the database, until it see:

- `COMMIT`: make changes permanent

```text
SQL > commit;
Commit complete.
```

- `ROLLBACK`: discard changes

```text
SQL> rollback;
Rollback complete.
```

### Aggregation

Standard and useful extension of First-Order Queries.

Aggregate (column) functions are introduced to,

- find number of tuples in a relation
- add values of an attribute (over the whole relation)
- find minimal/maximal values of an attribute

Can apply to _groups_ of tuples that with equal values for (selected) attributes.

Can _not_ be expressed in Relational Calculus

#### Aggregation in SQL

The same in SQL syntax:

```sql
SELECT x1,...,xk, agg1,...,aggl
FROM Q
GROUP BY x1,...,xk
```

Restrictions:

- All attributes in the `SELECT` clause that are _not_ in the scope of an aggregate function _must_ appear in the `GROUP BY` clause.
- $\texttt{agg}_{i}$ are of the form `count(y)`, `sum(y)`, `min(y)`, `max(y)`, or `avg(y)` where `y` is an attribute of `Q` (usually not in the `GROUP BY` clause).

#### Opertional Reading

1. Partition the input relation to groups with equal values of _grouping_ attributes.
2. On each of these partitions apply the _aggregate function_
3. Collect the results and form the answer

**Example** (count)  
For each publication count the number of authors:

```sql {.line-numbers}
select publication, count(author)
from wrote
group by publication;
```

**Example** (sum)  
For each author, count the number of article pages:

```sql {.line-numbers}
select author, sum(endpage-startpage+1) as pgs
from wrote, article
where publication = pubid
group by author;
```

... not quite correct: it doesn't list 0 pages for author 3.

### The `HAVING` Clause

The `WHERE` clause cannot impose conditions on values of aggregates,  
$\Rightarrow$ `WHERE` clause has to be used _before_ `GROUP BY`.

SQL allows a `HAVING` clause instead,  
$\Rightarrow$ like `WHERE`, but for aggregate values.

The aggregate functions using in the `HAVING` clause may be different from those in the `SELECT` clause; thr grouping, however, is common.

The `HAVING` clause is mere _synatctic sugar_, and cane be replaced by a nested query and a `WHERE` clause.

**Example**  
List publications with exactly one author:

```sql {.line-numbers}
select publication, count(author)
from wrote
group by publication
having count(author) = 1;
```

**Example**  
For every author, count the number of books and articles.

```sql {.line-numbers}
select distinct aid, name, count(publication)
from author, (
( select distinct author, publication
from wrote, book
where publication = pubid )
union all
( select distinct author, publication
from wrote, article
where publication = pubid ) ) ba
where aid = author
group by name, aid;
```

## Lecture SQL: Ordering Results, Duplicate Semantics, and NULL Values, _October 2, 2017_

### Ordering Results

No particular odering on the rows of a table can be assumed when queries are written.

No particular ordering of rows of an intermediate result in the query can be assumed either.

It is possible to order the final result of a query, using the `ORDER BY` clause at the end of the query.

General form:
$$\texttt{ORDER BY } e_{1}~[Dir_{1}], \ldots, e_{k}~[Dir_{k}]$$
where $Dir_{i}$ is either `ASC` or `DESC`.  
`ASC` is assumed by default.

**Example**  
List all authors in the databse in ascending order of their name.

```sql {.line-numbers}
select distinct *
from author
order by name asc;
```

### Multisets and Duplicates

SQL uses a _Multiset/Bag_ semantics rather than a _Set_ semantics:

- SQL tables are _multisets_ of tuples
- Originally for efficiency reasons

#### Duplicates and Queries

**Ideas**  
1\. an _finite valuation_ can appear _$k$ times_ ($k > 0$) as an answer to $Q$  
2\. the number of duplicates is a _function_ of the numbers of duplicates in subqueries

**Defn.** (Duplicate Semantics for Relational Calculus)  
${\bf DB}, \theta\{k\} \models \varphi$ reads "finite valuation $\theta$ appears $k$ times in $\varphi$'s answer"
$$\begin{aligned}
&{\bf DB}, \theta\{k\} \models R(x_{1},\ldots, x_{k}) &&\text{if } (\theta(x_{1}),\ldots,\theta(x_{k}))\in {\bf R}~~~k~\text{times} \\
&{\bf DB}, \theta\{1\} \models x_{i} = x_{j} &&\text{if } \theta(x_{i}) = \theta(x_{j}) \\
&{\bf DB}, \theta\{m\cdot n\} \models \varphi \wedge \psi &&\text{if } {\bf DB}, \theta_{|\varphi}\{m\}\models \varphi \text{ and } {\bf DB}, \theta_{|\psi}\{n\} \models \psi \\
&{\bf DB}, \theta\{m + n\} \models \varphi \vee \psi &&\text{if } {\bf DB}, \theta\{m\} \models \varphi \text{ and } {\bf DB}, \theta\{n\} \models \psi \\
&{\bf DB}, \theta\left\{\sum_{v \in D}n_{v}\right\} \models \exists{\bf x}\text{.}\varphi &&\text{if } {\bf DB}, \theta[x := v]\{n_{v}\} \models \varphi \\
&{\bf DB}, \theta\{\max(0, m - n)\} \models \varphi \wedge \neg\psi &&\text{if } {\bf DB}, \theta\{m\} \models \varphi \text{ and } {\bf DB}, \theta\{n\} \models \psi \\
&{\bf DB}, \theta\{1\} \models \text{DISTINCT}(\varphi) &&\text{if } {\bf DB}, \theta\{m\} \models \varphi \\
\end{aligned}$$

#### Duplicates and SQL

Allowing duplicates lead to additional _syntax_.

A duplicate elimination operator,  
$\Rightarrow$ `SELECT DISTINCT x` vs. `SELECT x` in `SELECT`-blocks.

Multiset (Bag) operators,  
$\Rightarrow$ equivalents of _set operations_, but with multiset semantics.

**Example**  
For publications with $n$ authors, we get $O(n^{2})$ answers.

```sql {.line-numbers}
select r1.publication
from wrote r1, wrote r2
where r1.publication = r2.publication
	and r1.author <> r2.author
```

#### Bag Operations

Bag union: `UNION ALL`  
$\Rightarrow$ additive union: bag containing all in $Q_{1}$ and $Q_{2}$.

Bag difference: `EXCEPT ALL`  
$\Rightarrow$ subtractive different.  
$\Rightarrow$ a bag all tuplies in $Q_{1}$ for which there is no "matching" tuple in $Q_{2}$.

Bag intersection: `INTERSECT ALL`  
A bag of all tuples taking the maximal number common to $Q_{1}$ and $Q_{2}$.

### "Pure" SQL Equivalence, Revisited

Nesting in the `WHERE` clause is syntactic sugar:

```sql
select r.b
from r
where r.a in (
	select b
	from s
)
```

```sql
select r.b
from r, (
	select distinct b
	from s
) as s
where r.a = s.b
```

Rewriting does not generally hold if `DISTINCT` is removed.

### Null

#### Value Inapplicable

Essentially _poor schema design_.

#### Value Unknown

**Idea**  
Unknown values can be replaced by any domain value (that satisfies integrity constraints), many possibilities (possible worlds).

#### Value Unknown and Queries

**Idea**  
Answers true in _all_ possible worlds $W$ of an incomplete $D$.

Is it (computationally) feasible?  
No! NP-hard to _undecidable_ except in trivial cases.

#### What Can We Do With `NULL`s in SQL

- Expressions
	- General rule: a `NULL` as a parameter to an operation makes (should make) the result `NULL`
	- $1 + \texttt{NULL} \rightarrow \texttt{NULL}$, $`foo' || \texttt{NULL} \rightarrow \texttt{NULL}$, etc.
- Predicates/Comparisons
	- Three-valued logic (crude approximation of "value unknown")
- Set operations
	- Unique sequal value for duplicates
- Aggregate operations
	- Doesn't "count" (i.e. value inapplicable)

#### `UNKNOWN` and Boolean Connectives

Boolean operations have to handle `UNKNOWN`...

#### `UNKNOWN` in `WHERE` Clauses

Additional syntax `IS TRUE`, `IS FALSE` and `IS UNKNOWN`  
$\Rightarrow$ `WHERE cond` shorthand for `WHERE cond IS TRUE`.

Special comparison `IS NULL`.

**Example**  
LIst all authors for which we don't know a URL of their home page.

```sql {.line-numbers}
select aid, name
from author
where url IS NULL
```

#### Counting NULLS

`count(URL)` counts only _non-NULL_ URL's.  
`count(*)` counts "rows".

### Outer Join

**Idea**  
Allows "NULL-padded" answers that "fail to saitsfy" a conjunct in a conjunction.

Extension of syntax for the `FROM` clause,  
$\Rightarrow$ `FROM R j-type JOIN S ON C`  
$\Rightarrow$ the j-type is one of `FULL`, `LEFT`, `RIGHT`, or `INNER`

Semantics (for $R(x,y), S(y,z)$, and $C = (r.y = s.y)$).

1. $\{(x,y,z):R(x,y) \wedge S(y,z)\}$
2. $\{(x, y, \texttt{NULL}):R(x, y) \wedge \neg(\exists z\text{.}S(y,z))\}$ for `LEFT` and `FULL`
3. $\{(\texttt{NULL}, y, z):S(y,z)\wedge\neg(\exists x\text{.}R(x,y))\}$ for `RIGHT` and `FULL`

$\Rightarrow$ syntactic sugar for `UNION ALL`

**Example**  
Authors who have written something.

```sql {.line-numbers}
select aid, publication
from author
left join wrote on aid=author
```

**Counting with Outer Join**  
For every author, count the number of publications.

```sql {.line-numbers}
select aid, count(publication) as pubs
from author
left join wrote on aid=author
group by aid
```

### Summary on `NULL` Values

`NULL`s are necessary evil, used to account for (small) irregularities in data.  
It should be used sparingly.  
It can _always_ be avoided, however some of the solutions may be inefficient.

Cannot escape `NULL`s in practice, _easy fix_ for blunders in schema design... also due to schema evolution, etc.

## Lecture: Application Programming and SQL, _October 4, 2017_

### Database Applications

SQL isn't sufficient to write general applications, connect it with a general purpose PL.

Language considerations:

- Library calls (CLI/ODBC)
- Embedded SQL
- Advanced _persistent_ PL (usually object-oriented)

Client-server:

- SQL runs on the server
- Application runs on the client

### Embedded SQL

SQL statements are _embedded_ into a _host language_ (C, C++, FORTRAN, ...).

The application is _preprocessed_, pure host language program + library calls.

| Advantages | Disadvantages |
| --- | --- |
| Preprocessing of parts of queries become possible | Needs precompiler |
| Much easier to use | Needs to be _bound_ to a database |

Considerations:

- How much can SQL be parameterized?
	- How to pass parameters into SQL?
	- How to get results?
	- Errors?
- Static vs. dynamic SQL statements

How much does the DBMS know about an application?

- Precompiling: `PREP`
- Binding: `BIND`

#### Development Process for Embedded SQL Applications

See written notes.

#### Application Structure

See written notes.

#### Declarations

Include SQL communication area:

```sql
EXEC SQL INCLUDE SQLCA;
```

Defines:

- The return code of SQL statements (sqlcode)
- The error messages (if any)
- Cannot live without it


SQL statements inserted using magic words,

```sql
EXEC SQL sql-statement;
```

#### Host Variables

SQL statements can have parameters that are _host_ variables in the embeddeding language.

Host variables communicate _single values_ between a SQL statement and the embedding language.  
Must be declared within SQL declare sections:

```sql
EXEC SQL BEGIN DECLARE SECTION;
	declarations-of-variables-to-be-used-here
EXEC SQL END DECLARE SECTION;
```

Used in the `EXEC SQL` statements; to distinguish them from SQL identifiers, they are preceded by ":" (colon).

#### Errors

What if a SQL statement fails?  
Check `sqlcode != 0`  
Use "exception" handling:

```sql
EXEC SQL WHENEVER SQLERROR    GO TO lbl;
EXEC SQL WHENEVER SQLWARNING  GO TO lbl;
EXEC SQL WHENEVER NOT FOUND   GO TO lbl;
```

$\Rightarrow$ designed for COBOL (lbl has to be in scope).

##### Dummy Application (DB2)

```c
#include <stdio.h>
#include "util.h"

EXEC SQL INCLUDE SQLCA;

int main(int argc, char *argv[]) {
		EXEC SQL BEGIN DECLARE SECTION;
			char db[6] = "DBCLASS";
		EXEC SQL END DECLARE SECTION;
		printf("Sample C program: CONNECT\n");
		EXEC SQL WHENEVER SQLERROR GO TO error;
		EXEC SQL CONNECT TO :db;
		printf("Connected to DB2\n");
	// Do your stuff herr
		EXEC SQL COMMIT;
		EXEC SQL CONNECT reset;
		exit(0);
	error:
		check_error("My error", &sqlca);
		EXEC SQL WHENEVER SQLERROR CONTINUE;
		EXEC SQL ROLLBACK;
		EXEC SQL CONNECT reset;
		exit(1);
}
```

##### Dummy Application (Oracle)

```c
#include <stdio.h>

EXEC SQL INCLUDE SQLCA;

int main(int argc, char *argv[]) {
		EXEC SQL BEGIN DECLARE SECTION;
			char db[6] = "DBCLASS";
			char pwd[10];
		EXEC SQL END DECLARE SECTION;
		printf("Sample C program: CONNECT\n");
		strncpy(pwd, getpass("Password: "), 10);
		EXEC SQL WHENEVER SQLERROR GO TO error;
		EXEC SQL CONNECT :user IDENTIFIED BY :pwd;
		printf("Connected to Oracle\n");
	// Do your stuff here
		EXEC SQL COMMIT RELEASE;
		exit(0);
	error:
		sqlca.sqlerrm.sqlerrmc[sqlca.sqlerrm.sqlerrml] = '\0';
		printf("MyError %s\n", sqlca.sqlerrm.sqlerrmc);
		EXEC SQL WHENEVER SQLERROR CONTINUE;
		EXEC SQL ROLLBACK RELEASE;
		exit(1);
}
```

#### Preparing Your Application (DB2)

1. Write the application in a file called `<name>.sqc`
2. Preprocess the application:  
	`db2 prep <name>.sqc`
3. Compile the application:  
	`cc -c -O <name>.c`
4. Link with DB2 libraries:  
	`cc -o <name> <name.o> -L ... -l ...`
5. Run it:  
	`./<name> [arguments]`

Typically comes with a Makefile,  
$\Rightarrow$ set options  
$\Rightarrow$ knows the path(s) and libraries

### "Real" SQL Statements

Simple statements:  
$\Rightarrow$ "constant" statements  
$\Rightarrow$ statements with parameters  
$\Rightarrow$ stsatements returning a single tuple

General queries with many answers.  
Dynamic queries.

#### Simple Application

Write a program that prints out the title of the publication for each publication id supplied as an argument,

```c
main(int argc, char *argv[]) {
	...
	printf("Connected to DB2\n");
	for (i = 1; i <argc; i++) {
		strncpy(pubid, argv[i], 8);

		EXEC SQL WHENEVER NOT FOUND GO TO nope;

		ECEC SEQL SELECT title INTO :title
			FROM publication
			WHERE pubid = :pubid;
		
		printf("%10s: %s\n", pubid, title);
		continue;
	nope:
		printf("%10s: *** not found *** \n", pubid);
	}
	...
}
```

Note: at most _one_ title is returned for each pubid.

### NULLs and Indicator Variables

What if a host variable is assigned a `NULL`?  
Not a valid value in the datatype.  
ESQL uses an extra _Indicator_ variable, e.g.:

```sql
smallint ind;
SELECT firstname INTO :firstname
	INDICATOR :ind
FROM ...
```

If $\texttt{ind} < 0$ then $\texttt{firstname}$ is `NULL`.

If the indicator variable is not provided and the result is a null, we get an **run-time error**.  
The same rules apply for host variables in updates.

### Impedance Mismatch

What if we `EXEC SQL` a query and it _returns more than one tuple_?

1. Declare the cursor,
	```sql
	EXEC SQL DECLARE name CURSOR
		FOR query;
	```
2. Iterate over it:
	```c
	EXEC SQL OPEN name;
	EXEC SQL WHENEVER NOT FOUND GO TO end;
	for (;;) {
		set up host parameters
		EXEC SQL FETCH name
			INTO host variables;
		process the fetched tuple
	}
	end:
		EXEC SQL CLOSE name;
	```

#### Application with a Cursor

Write a program that lists all author names and publication titles with author name matching a pattern given as an argument,

```c
main(int argc, char *argv[]) {
	...
	strncpy(apat,argv[1],8);
	EXEC SQL DECLARE author CURSOR
		FOR SELECT name, title
		FROM author , wrote, publication
		WHERE name LIKE :apat
		AND aid=author AND pubid=publication;
	EXEC SQL OPEN author;
	EXEC SQL WHENEVER NOT FOUND GO TO end;
	for (;;) {
		EXEC SQL FETCH author INTO :name, title;
		printf("%10s -> %20s: %s\n",apat,name,title);
	};
	end:
	...
}
```

### Embedded SQL Summary

Declarations:

```c
EXEC SQL INCLUDE SQLCA;
EXEC SQL BEGIN DECLARE SECTION;
	host variables here
EXEC SQL END DECLARE SECTION;
```

Simple statements:

```c
EXEC SQL sql statement;
```

Queries (with multiple answers):

```c
EXEC SQL DECLARE id CURSOR for qry;
EXEC SQL OPEN id;
do {
	EXEC SQL FETCH id INTO vars;
} while (SQLCODE == 0);
EXEC SQL CLOSE id;
```

Remember to check errors!

### Stored Procedures

**Idea**  
A _stored procedure_ executes applicatino logic directly inside the DBMS process.

Possible implemenations

- Invoke externally-compiled application
- SQL/PSM (or vendor-specific language)

Possible advantages of stored procedures

1. Minimize data transfer costs
2. Centralize application code
3. Logical independence

#### Example: Atomic-Valued Function

```sql {.line-numbers}
CREATE FUNCTION sumSalaries(dept CHAR(3))
	RETURNS DECIMAL (9, 2)
LANGUAGE SQL
RETURN
	SELECT sum(salary)
	FROM employee
	WHERE workdept = dept
```

#### Example: Table-Valued Function

```sql {.line-numbers}
CREATE FUNCTION deptSalariesF(dept CHAR(3))
	RETURNS TABLE(salary DECIMAL(9, 2))
LANGUAGE SQL
RETURN
	SELECT salary
	FROM employee
	WHERE workdept = dept
```

#### Example: Branching

```sql {.line-numbers}
CREATE PROCEDURE UPDATE_SALARY_IF
	(IN employee_number CHAR(6), INOUT rating SMALLINT)
LANGUAGE SQL
BEGIN
	DELCARE not_found CONDITION FOR SQLSTATE '02000';
	DECLARE EXIT HANDLER FOR not_found
		SET rating = 01;
	IF rating = 1 THEN
		UPDATE employee
		SET salary = salary * 1.10, bonus = 1000
		WHERE empno = employee_number;
	ELSEIF rating = 2 THEN
		UPDATE employee
		SET salary = salary * 1.05, bonus = 500
		WHERE empno = employee_number;
	ELSE
		UPDATE employee
		SET salary = salary * 1.03, bonus = 0
		WHERE empno = employee_number;
	END IF;
END
```

## Lecture: Dynamic SQL

**Goal**  
Execute a string as a SQL statement.

Problems:

- How do we know a string is a valid statement?
	- Parsing and compilation?
- How do we execute?
	- Queries? (Where does the answer go?)
	- Updates? (How many rows affected?)
- What if we don't know anything about the string?

We delveop an "_adhoc_" application that accepts an SQL statement as an argument and executes it (and prints out answers, if any).

**Dynamic SQL** A roadmap,  
See written notes.

### `EXECUTE IMMEDIATE`

Execution of _non-parametric_ statements _without answer(s)_,

```sql
EXEC SQL EXECUTE IMMEDIATE :string;
```

where `:string` is a host variable containing the ASCII representation of the query.

`:string` may not return an answer nor contain paramters.  
Used for constant stsatements executed only once, `:string` is _compiled_ every time we pass through.

### `PREPARE`

_Compile_ a `:string` into a `stmt`

```sql
EXEC SQL PREPARE stmt FROM :string;
```

`stmt` can now be used for repeatedly executed statements, avoids recompilation each time we want to execute them.

`:string` may be a query (and return answers).  
`:string` may contian paramters.  
`stmt` is _not_ a host variable but an identifier of the statement used by the preprocessor (note: _cannot_ be used in recursion)

### Parametric Statements

- Static embedded SQL
	- Host variables as parameters
- Dynamic SQL (strings) and _parameters_
	- We can change the string (recompilation)
	- Use _parameter marker_, a "?" in the string

**Idea**  
Values for "?"s are substitued when the statement is to be executed.

#### Simple Statement: `EXECUTE`

```sql
EXEC SQL EXECUTE stmt
	USING :var1 [, ..., :vark];
```

For statements that don't return tuples

- Database modification (`INSERT`, ...)
- Transactions (`COMMIT`)
- Data definition (`CREATE ...`)

Values of `:var1`, ..., `:vark` are substituted for parameter markers (in order of appearanace).  
Mistmach causes SQL _runtime_ errors!

#### Query With Many Answers: `CURSOR`

```sql
EXEC SQL DECLARE name CURSOR for stmt;
EXEC SQL OPEN cname
	USING :var1 [, ..., :vark];
EXEC SQL FETCH cname
	INTO :out1 [, ..., :outn];
EXEC SQL CLOSE cname;
```

_Cursors_ for queries (like in the static case).  
`:var1, ..., :vark` - supply query parameters.  
`:out1, ..., :outn` - store resulting tuple.  
`sqlca.sqlerrd[2]` the number of retrieved tuples.

#### Unknown Number/Types of Variables

Use a _dynamic descriptor area_.  
The standard is,

- `ALLOCATE DESCRIPTOR descr`
- `GET DESCRIPTOR descr what`  
	`SET DESCRIPTOR descr what`  
	where `what` is
	- get/set the value for `COUNT`
	- get/set value for the $i$-th attribute: `VALUE :i assgn`, can use `DATA, TYPE, INDICATOR, ...`
- `DESCRIBE [INPUT|OUTPUT] stmt INTO descr`

In practice, use `sqlda` descriptor explicitly.

### SQLDA: A Description of Tuple Structure

The `sqlda` data structure is a SQL _description area_ that defines how a single tuple looks like, where are the data, etc.  
This is how the DBMS communicates with the application.

It contains (amongst others):

- The string `'SQLSA  '` (for identification)
- Number of allocated entries for attributes
- Number of actual attributes, 0 if none
- For every attribute,
	1. (numeric code of) type
	2. length of storage for the attribute
	3. pointer to a data variable
	4. pointer to a indicator variable
	5. name (string and its length)

#### SQLDA in DB2

```c
struct sqlname /* AttributeName */
{
	short length;               /* Name length [1..30] */
	char data[30];              /* Variable or Column name */
};
struct sqlvar /* Attribute Descriptor */
{
	short sqltype;              /* Variable data type */
	short sqllen;               /* Variable data length */
	char *SQL_POINTER sqldata;  /* data buffer */
	short *SQL_POINTER sqlind;  /* null indiciator */
	struct sqlname sqlname;     /* Variable name */
};
struct sqlda /* Main SQLDA */
{
	char sqldaid[8];            /* Eye catcher = ’SQLDA ’ */
	long sqldabc;               /* SQLDA size in bytes=16+44*SQLN */
	short sqln;                 /* Number of SQLVAR elements */
	short sqld;                 /* Number of used SQLVAR elements */
	struct sqlvar sqlvar[1];    /* first SQLVAR element */
};
```

#### SQLDA in Oracle

```c
struct SQLDA {
	long N;     /* Descriptor size in number of entries */
	char *V[];  /* Arr of addresses of main variables (data) */
	long L[];   /* Arr of lengths of data buffers */
	short T[];  /* Arr of types of buffers */
	short *I[]; /* Arr of addresses of indicator vars */
	long F;     /* Number of variables found by DESCRIBE */
	char *S[];  /* Arr of variable name pointers */
	short M[];  /* Arr of max lengths of attribute names */
	short C[];  /* Arr of current lengths of attribute names */
	char *X[];  /* Arr of indicator name pointers */
	short Y[];  /* Arr of max lengths of ind. names */
	short Z[];  /* Arr of cur lengths of ind. names */
};
```

### `DESCRIBE`

A prepared statement can be _described_; the description is stored in SQLDA.

```sql
EXEC SQL DESCRIBE stmt INTO sqlda
```

The result is:

- The number of result attributes
	- 0: not a query
- For every attribute in the answer
	- Its name and length
	- Its type

### SQLDA and Parameter Passing

SQLDA descriptor to supply parameters and/or to get the result: _fill in the values and types_ and then use the description area as follows,

```sql
EXEC SQL EXECUTE stmt
	USING DESCRIPTOR :sqlda;

EXEC SQL OPEN cname
	USING DESCRIPTOR :sqlda;

EXEC SQL FETCH cname
	USING DESCRIPTOR :sqlda;
```

`:sqlda` essentially replaces `:var1, ..., :vark`

### `adhoc.sqc`

`adhoc` is an app that executes SQL statement provided as its argument on the command line.

```c {.line-numbers}
/* Declarations */
#include <stdio.h>
#include <string.h>

EXEC SQL INCLUDE SQLCA;
EXEC SQL INCLUDE SQLDA;

EXEC SQL BEGIN DECLARE SECTION;
	char db[6] = "cs448";
	char sqlstmt[1000];
EXEC SQL END DECLARE SECTION;

struct sqlda *select;

/* Start up and prepare the statement */
int main(int argc, char *argv[]) {
	int i, isnull; short type;
	printf("Sample C program : ADHOC interactive SQL\n");

	EXEC SQL WHENEVER SQLERROR GO TO error;

	EXEC SQL CONNECT TO :db;
	printf("Connected to DB2\n");

	strncpy(sqlstmt,argv[1],1000);
	printf("Processing <%s>\n",sqlstmt);

	EXEC SQL PREPARE stmt FROM :sqlstmt;

	init_da(&select,1);

	EXEC SQL DESCRIBE stmt INTO :*select;

	i= select->sqld;

	/* Query */
	if (i > 0) {
		printf(" ... looks like a query\n");

		/* new SQLDA to hold enough descriptors for answer */
		init_da(&select,i);

		/* get the names, types, etc... */
		EXEC SQL DESCRIBE stmt INTO :*select;
		printf("Number of select variables <%d>\n",select->sqld);
		for (i = 0; i < select->sqld; i++) {
			printf(" variable %d <%.*s (%d%s [%d])>\n",
				i,
				select->sqlvar[i].sqlname.length,
				select->sqlvar[i].sqlname.data,
				select->sqlvar[i].sqltype,
				((select->sqlvar[i].sqltype&1) == 1 ?
					"": " not null"),
				select->sqlvar[i].sqllen);
		}
		printf("\n");

		/* prepare buffers and print a header */
		for (i = 0; i < select->sqld; i++) {
			select->sqlvar[i].sqldata=malloc(select->sqlvar[i].sqllen);
			select->sqlvar[i].sqlind=malloc(sizeof(short));
			*select->sqlvar[i].sqlind = 0;
		}

		for (i = 0; i < select->sqld; i++) {
			printf("%-*.*s ",select->sqlvar[i].sqllen,
				select->sqlvar[i].sqlname.length,
				select->sqlvar[i].sqlname.data);
		}
		printf("\n");

		/* fetch and print answers */
		EXEC SQL DECLARE cstmt CURSOR FOR stmt;
		EXEC SQL OPEN cstmt;
		EXEC SQL WHENEVER NOT FOUND GO TO end;
		for (; ;) {
			EXEC SQL FETCH cstmt USING DESCRIPTOR :*select;
			for (i=0; i<select->sqld; i++ ) {
				if ( *(select->sqlvar[i].sqlind) < 0 ) {
					print_var("NULL", select->sqlvar[i].sqltype,
						select->sqlvar[i].sqlname.length,
						select->sqlvar[i].sqllen);
				} else {
					print_var(select->sqlvar[i].sqldata,
						select->sqlvar[i].sqltype,
						select->sqlvar[i].sqlname.length,
						select->sqlvar[i].sqllen);
				}
			}
			printf("\n");
		}
	end: printf("\n");
	/* is a simple statement */
	} else {
		printf(" ... looks like an update\n");
		EXEC SQL EXECUTE stmt;
	}

	/* and get out of here */
	EXEC SQL COMMIT;
	EXEC SQL CONNECT reset;
	exit(0);
error:
	check_error("My error",&sqlca);
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL ROLLBACK;
	EXEC SQL CONNECT reset;
	exit(1);
}
```

**Example**  
`./adhoc "select * from author"`

### Summary on Dynamic SQL

Given a string,  
$\Rightarrow$ unknown: `DESCRIBE`  
$\Rightarrow$ simple statement used one: `EXECUTE IMMEDIATE`  
$\Rightarrow$ otherwise: `PREPARE`

Given a statement handle (using `PREPARE`),  
$\Rightarrow$ simple statement: `EXECUTE`  
$\Rightarrow$ query: `DECLARE CURSOR` and then process as an ordinary cursor

Note: Supply correct host variables/sqlda for all parameter and answer tuples.

## Lecture: Data Mondelling and the Entity-Relationship Model, _October 18, 2017_

See written notes.
