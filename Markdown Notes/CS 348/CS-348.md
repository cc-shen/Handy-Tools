# CS 348 - Introduction to Database Management

---

## Lecture September 11, 2017

### Topics

1. Why do we use databases?
	- Functionality provided by a Database Management System
2. How do we use a Database Management System?
	- Relational model
	- Foundational query languages and SQL
	- Transactions, concurrency, and recovery
3. How do we design a database?
	- Entity-Relationship (ER) modelling
	- Accommodating and enforcing constraints

### What is "Data"

- ANSI definition,
	- _facts_, _concepts_, or _instructions_ in a formalized manner suitable for humans or by automatic means
	- _meaning_

### Early Data Management - Ancient History

Data are not stored on disk.  
One data set per program. High data redundancy.  
See written notes for diagram.

### File Processing - More Recent History

Data are stored in files with interface between programs and files.  
Various access methods exist (e.g., sequential, indexed, random).  
One file corresponds to one or several programs.  
See written notes for diagram.

### Database Approach

See written notes for diagrams.

### What is a Database

**Database**  
A _large_ and _persistent_ collection of (more-or-less similar) pieces of
information organized in a way that facilitates efficient _retrieval_ and
_modification_.  
=> structure of the _database_ is determined by a **data model**.

Examples:

- a file cabinet
- a library system
- a personnel management system

**Database Management System (DBMS)**  
A program (or set of programs) that manages details related to storage
and access for a database.

### Database Management System

**Idea**  
Abstract common functions and creates a uniform well defined interface for applications accessing data.

1. Data Model, all data stored in a well defined way
2. Access control, only authorized people get to see/modify it
3. Concurrency control, multiple concurrent applications access data
4. Database recovery, nothing gets accidentally lost
5. Database maintenance

### Schema and Instance

A **schema** is a description of the data interface to the database. i.e. _how the data is organized_.

A **database instance** is a database (real data) that conforms to a given schema.  
A schema can (_and typically does_) have many instances.

### Applications of Databases

Original:

- Inventory control
- Payroll
- Banking and financial systems
- Reservation systems

More recent:

- Computer aided design (CAD)
- Software development (CASE, SDE/SFE)
- Telecommunication systems
- E-commerce
- Dynamic/Personalized web content

### Why Database Technology

Data constitute an organization asset $\Rightarrow$ _integrated control_.  
&nbsp;&nbsp;&nbsp; Reduction of redundancy  
&nbsp;&nbsp;&nbsp; Avoidance of inconsistency  
&nbsp;&nbsp;&nbsp; Data integrity  
&nbsp;&nbsp;&nbsp; Shareability  
&nbsp;&nbsp;&nbsp; Improved security

Programmer productivity $\Rightarrow$ _data independence_.  
&nbsp;&nbsp;&nbsp; Programmers do not have to deal with data organization.

### Three Level Schema Architecture

1. _External schema (view)_

	What the application programs and user see; may differ for different users of the same database.

2. _Conceptual schema_

	Description of the logical structure of _all_ data in the database.

3. _Physical schema_

	Description of physical aspects (selection of files, devices, storage algorithms, etc.)

### Data Independence

**Idea**  
Applications do not access data directly but, rather through an abstract data model provided by the DBMS.

Two kinds of data independence:  
_Physical_: applications immune to changes in storage structures.  
_Logical_: applications immune to changes in data organization.

_Note_: one of the most important reason to use a DBMS.

### Transaction

When multiple applications access the same data, undesirable results occur.

**Idea**  
Every application may think it is the sole application accessing the data.  
The DBMS should guarantee correct execution.

A **transaction**, is then, an application-specific atomic and durable unit of work.

Properties of transactions:

- _Atomic_: a transaction occurs entirely, or not at all
- _Consistency_: each transaction preserves the consistency of the database
- _Isolated_: concurrent transactions do not interfere with each other
- _Durable_: a transaction's changes are permanent once completed

### Interfacing to the DBMS

**Data Definition Language** (**DDL**): for specifying schemas,  
&nbsp;&nbsp;&nbsp; May have different DDLs for external schema, conceptual schema, internal schema
&nbsp;&nbsp;&nbsp; Information is stored in the **data dictionary**, or **catalog**

**Data Manipulation Language** (**DML**): for specifying queries and updates,  
&nbsp;&nbsp;&nbsp; **navigational** (procedural)  
&nbsp;&nbsp;&nbsp; **non-navigational** (declarative)

### Types of Database Users

- End User
	- Accesses DB indirectly through forms or other query-generating applications, or
	- Generates ad-hoc queries using the DML
- Application developer
	- Designs and implements applications that accesses the database
- Database administrator (DBA)
	- Manages conceptual schema
	- Assists with application view integration
	- Monitors and tunes DBMS performance

### Brief History of Data Management

#### Ancient

2000 BC: Sumerian Records  
&nbsp; 350 BC: _Syllogisms (Aristotle)_  
&nbsp; 296 BC: Library of Alexandria  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1879: _Modern Logic (Frege)_  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1884: U.S. Census (Hollerith)  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1941: _Model Theory (Tarski)_

#### 1950s

First generation.  
&nbsp;&nbsp;&nbsp; Batch processing.  
&nbsp;&nbsp;&nbsp; Sequential files and tapes  
&nbsp;&nbsp;&nbsp; Input on punched cards

#### 1960s

Second generation.  
&nbsp;&nbsp;&nbsp; Disk enabled random access files  
&nbsp;&nbsp;&nbsp; New access methods (ISAM, hash files)  
&nbsp;&nbsp;&nbsp; Mostly batch with some interactivity  
&nbsp;&nbsp;&nbsp; Independent applications with separate files  
&nbsp;&nbsp;&nbsp; Growing applications base

As application base grows, we got,  
&nbsp;&nbsp;&nbsp; Many shared files  
&nbsp;&nbsp;&nbsp; A multitude of file structures  
&nbsp;&nbsp;&nbsp; A need to exchange data among applications

A variety of problems,  
&nbsp;&nbsp;&nbsp; _Redundancy_: multiple copies  
&nbsp;&nbsp;&nbsp; _Inconsistency_: independent updates  
&nbsp;&nbsp;&nbsp; _Inaccuracy_: concurrent updates  
&nbsp;&nbsp;&nbsp; _Incompatibility_: multiple formats  
&nbsp;&nbsp;&nbsp; _Insecurity_: proliferation  
&nbsp;&nbsp;&nbsp; _Inauditability_: poor chain of responsibility  
&nbsp;&nbsp;&nbsp; _Inflexibility_: changes are difficult to apply

Hierarchial data model,

- IBM's Information Management System (IMS): concurrent access
- Only allow 1:N parent-child relationships (i.e. a tree)
- Hierarchy can be exploited for efficiency
- Queries navigate up and down trees - one record at a time
- Data access language embedded in business processing language
- Difficult to express some queries

Network data model,

- Charles Bachman's Integrated Data Store (IDS)
- Model standardized by Conference On Data Systems Languages (CODASYL)
- Data organized as collections of sets of records
- Separation of physical data representation from users' view of data
- Pointers between records represent relationships
- Set types encoded as lists
- Queries navigate between records - still one record at a time

#### 1970s

Edgar Codd proposes relational data model (1970), firm mathematical foundation $\rightarrow$ _declarative queries_.

Charles Bachman wins ACM Turing Award (1973), "The programmer as Navigator."

Peter Chen proposes E-R model (1976).

Transaction concepts (Jim Gray and others).

IBM's _System R_ and UC Berkeley's _Ingres_ systems demonstrate feasibility of relational DBMS (late 1970s).

#### 1980s

Development of commercial relational technology; IBM DB2, Oracle, Informix, Sybase.

Edgar Codd wins ACM Turning Award (1981).

SQL standarization efforts through ANSI and ISO.

Object-oriented DBMSs (late 1980s to middle of 1990s),  
&nbsp;&nbsp;&nbsp; Persistent objects  
&nbsp;&nbsp;&nbsp; Object IDs, methods, inheritance  
&nbsp;&nbsp;&nbsp; Navigational interface reminiscent of hierarchical model

#### 1990s - Present

Continued expansion of SQL and system capabilities.

New application areas includes,

- Internet
- Online Analytic Processing (OLAP)
- Data warehousing
- Embedded systems
- Multimedia
- XML
- Data streams

Jim Gray wins ACM Turing Award (1998).

Relational DBMSs incorporate objects (late 1990s).

Many new DBs in the industry (2000+).

Michael Stonebraker wins ACM Turing Award (2014).

### Summary

DBMS helps data management:

- Removes common code from applications
- Provides uniform access to data
- Guarantees data integrity
- Manages concurrent access
- Protects against system failure
- Sets access policies for data

---

## Lecture Relational Model, September 13, 2017

### The Relational Model

**Idea**  
All information is organized in (a finite number of) relations.

Features:

- Simple and clean data model
- Powerful and declarative query./update languages
- Semantic integrity constraints
- Data independence

### Relational Structures/Databases

Components:

- Universe
	- A set of values ${\bf D}$ with equality ($=$)
- Relation
	- Schema: name $R$, arity $k$ (the number of attributes)
	- Instance: a relation ${\bf R} \subseteq {\bf D}^{k}$
- Database
	- Schema: finite set of relation schemes
	- Instance: a relation ${\bf R}_{i}$ for each $R_{i}$

**Notation**  
Signature: $\rho = (R_{1}, ..., R_{n})$  
Instance: ${\bf D} = ({\bf D}, =, R_{i}, ..., R_{n})$

Relations are often called tables.

### Simple (Atomic) "Truths"

**Idea**  
Relationships between objects (tuples) that are present in an instance are true, absent relationships are false.

### Relational Calculus: Syntax

**Idea**  
Complex statements about truth can be formulated using the language of first-order logic.

**Defn.** (Syntax)  
Given a database schema $\rho = (R_{1}, ..., R_{k})$ and a set of variable names $\{x_{1}, x_{2}, ...\}$, formulas are defined by
$$
\varphi
::=
\underbrace{
	\underbrace{
		\underbrace{
			R_{i}(x_{i_{1}}, ..., x_{i_{k}})~|~x_{i} = x_{j}~|~\varphi \wedge \varphi~|~\exists x_{i}.\varphi
		}_{\text{conjunctive formulas}}~|~\varphi \vee \varphi
	}_{\text{positive formulas}}~|~\neg\varphi
}_{\text{first-order formulas}}
$$

#### First-order Variables and Valuations

A **valuation** is a function
$$\theta:~\{x_{1}, x_{2}, ...\} \rightarrow {\bf D}$$
that maps variable names to values in the universe.

**Idea**  
Ansers to queries $\Leftrightarrow$ valuations to free variables that make the formula true with respect to a database.

#### Complete Semantics

**Defn.**  
The _truth_ of formulas is defined with respect to

1. a _database instance_ ${\bf D} = ({\bf D}, =, {\bf R}, {\bf S}, ...)$, and
2. a _valuation_ $\theta:~\{x_{1}, x_{2}, ...\} \rightarrow {\bf D}$

as follows:

$$
\begin{aligned}
{\bf D}, \theta &\models R(x_{i_{1}}, ..., x_{i_{k}}) &\text{if } &R \in \rho,~(\theta(x_{i_{1}}), ..., \theta(x_{i_{k}})) \in {\bf R} \\
{\bf D}, \theta &\models x_{i} = x_{j} &\text{if } &\theta(x_{i}) = \theta(x_{j})\\
{\bf D}, \theta &\models \varphi \wedge \psi &\text{if } &{\bf D}, \theta \models \varphi \text{ and } {\bf D}, \theta \models \psi\\
{\bf D}, \theta &\models \neg\varphi &\text{if } &\text{not } {\bf D}, \theta \models \varphi \\
{\bf D}, \theta &\models \exists x_{i}.\varphi &\text{if } &{\bf D}, \theta[x_{i} \mapsto v] \models \varphi \text{ for some } v \in {\bf D}
\end{aligned}
$$

**Defn.**  
An answer to a query $\{(x_{1}, ..., x_{k}) | \varphi\}$ over $\bf D$ is a _relation_:
$$\{(\theta(x_{1}), ..., \theta(x_{k}))~|~{\bf D}, \theta \models \varphi\}$$
where $\{x_{1}, ..., x_{k}\} = FV(\varphi)$.

#### Equivalences and Syntactic Sugar

Boolean Equivalences

- $\neg(\neg\varphi_{1}) \equiv \varphi_{1}$
- $\varphi_{1} \vee \varphi_{2} \equiv \neg(\neg\varphi_{1} \wedge \neg\varphi_{2})$
- $\varphi_{1} \rightarrow \varphi_{2} \equiv \neg\varphi_{1} \vee \varphi_{2}$
- $\varphi_{1} \leftrightarrow \varphi_{2} \equiv (\varphi_{1} \rightarrow \varphi_{2}) \wedge (\varphi_{2} \rightarrow \varphi_{1}) $
- ...

First-order Equivalences

- $\forall x.\varphi \equiv \neg\exists x.\neg\varphi$

---

## Lecture September 18, 2017
