\documentclass[12pt]{article}
\usepackage[margin = 1.5in]{geometry}
\setlength{\parindent}{0in}
\usepackage{amsfonts, amssymb, amsthm, mathtools, tikz, qtree, float}
\usepackage{algpseudocode}
\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage[T1]{fontenc}
\usepackage{ae, aecompl, color}
\usepackage[pdftex, pdfauthor={Charles Shen}, pdftitle={CS 240: Data Structures and Data Management}, pdfsubject={Lecture notes from CS 240: at the University of Waterloo}, pdfkeywords={course notes, notes, Waterloo, University of Waterloo}, pdfproducer={LaTeX}, pdfcreator={pdflatex}]{hyperref}
\usepackage{cleveref}
\usepackage{wrapfig}
\usepackage{multicol}

\DeclarePairedDelimiter{\set}{\lbrace}{\rbrace}

\definecolor{darkish-blue}{RGB}{25,103,185}

\hypersetup{
  colorlinks,
  citecolor=darkish-blue,
  filecolor=darkish-blue,
  linkcolor=darkish-blue,
  urlcolor=darkish-blue
}

\theoremstyle{definition}
\newtheorem*{defn}{Definition}
\newtheorem*{theorem}{Theorem}
\newtheorem*{corollary}{Corollary}
\newtheorem{ex}{Example}[section]

\crefname{ex}{Example}{Example}

\setlength{\marginparwidth}{1.5in}
\newcommand{\lecture}[1]{
  \marginpar{{
    \footnotesize $\leftarrow$ \underline{#1}}
  }
}

\newcommand{\includePicture}[3]{
  \begin{figure}[!ht]
  \centering
  \scalebox{#1}{\includegraphics{#2}}
  \caption{#3}
  \end{figure}
}

\allowdisplaybreaks

\makeatletter
\def\blfootnote{\gdef\@thefnmark{}\@footnotetext}
\makeatother

%%%%%%%%%%%%%%%%%%%%%
%% D O C U M E N T %%
%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\let\ref\Cref

\title{\bf{CS 240: Data Structure and Data Management}}
\date{Spring 2016, University of Waterloo \\ \center Formulas, run time, and more.}
\author{Charles Shen}

\blfootnote{Feel free to email feedback to me at
\href{mailto:echen902@gmail.com}{echen902@gmail.com}.}

\maketitle
\newpage
\tableofcontents
\newpage

\section{Order Notation}
\subsection{Big O}
O-Notation (bound from above; worst case):
$$f(n) \in O(g(n))$$
if there exists constants $c, n_{0} > 0$ such that
$$0 \leq f(n) \leq cg(n) ~~~\forall n \geq n_{0}$$

\subsection{Big Omega}
$\Omega$-Notation (bound from below; best case):
$$f(n) \in \Omega(g(n))$$
if there exists constants $c, n_{0} > 0$ such that
$$0 \leq cg(n) \leq f(n) ~~~\forall n \geq n_{0}$$

\subsection{Theta Bound}
$\theta$-Notation (tight bound):
$$f(n) \in \theta(g(n))$$
if there exists constants $c_{1}, c_{2}, n_{0} > 0$ such that
$$c_{1}g(n) \leq f(n) \leq c_{2}g(n) ~~~\forall n \geq n_{0}$$

\subsection{Little o}
o-Notation (bound from above for all):
$$f(n) \in o(g(n))$$
if for all constants $c > 0$, there exists a constant $n_{0} > 0$ such that
$$0 \leq f(n) \leq cg(n) ~~~\forall n \geq n_{0}$$

\subsection{Little omega}
$\omega$-Notation (bound from below for all):
$$f(n) \in o(g(n))$$
if for all constants $c > 0$, there exists a constant $n_{0} > 0$ such that
$$0 \leq cg(n) \leq cf(n) ~~~\forall n \geq n_{0}$$

\subsection{Techniques for Order Notation}
Suppose that $f(n) > 0$ and $g(n) > 0$ for all $n \geq n_{0}$. \\
Suppose that
$$L = \lim_{n\to\infty}\frac{f(n)}{g(n)}$$
Then
\begin{align*}
  f(n) \in
  \begin{cases}
    o(g(n)) ~~&\text{if } L = 0 \\
    \theta(g(n)) ~~& \text{if } 0 < L < \infty \\
    \omega(g(n)) ~~&\text{if } L = \infty
  \end{cases}
\end{align*}

\subsection{Relationships Between Order Notations}
\begin{align*}
  f(n) \in \theta(g(n)) &\Longleftrightarrow g(n) \in \theta(f(n))& \\
  f(n) \in O(g(n)) &\Longleftrightarrow g(n) \in \Omega(f(n))& \\
  f(n) \in o(g(n)) &\Longleftrightarrow g(n) \in \omega(f(n))& \\ \\
  f(n) \in \theta(g(n)) &\Longleftrightarrow
    f(n) \in O(g(n)) \text{ and } f(n) \Omega(g(n))& \\
  f(n) \in o(g(n)) &\Longleftrightarrow f(n) \in O(g(n)) \\
  f(n) \in o(g(n)) &\Longleftrightarrow f(n) \not\in \Omega(g(n)) \\
  f(n) \in \omega(g(n)) &\Longleftrightarrow f(n) \in \Omega(g(n)) \\
  f(n) \in \omega(g(n)) &\Longleftrightarrow f(n) \not\in O(g(n))
\end{align*}

\subsection{Algebra of Order Notation}
Transitivity: If $f(n) \in O(g(n))$ and $g(n) \in O(h(n))$ then $f(n) \in O(h(n))$. \\

``Maximum'' Rules: Suppose that $f(n) > 0$ and $g(n) > 0$ for all $n \geq n_{0}$, then:
\begin{align*}
  O(f(n) + g(n)) &\Longleftrightarrow O(max\{f(n), g(n)\}) \\
  \theta(f(n) + g(n)) &\Longleftrightarrow \theta(max\{f(n), g(n)\}) \\
  \Omega(f(n) + g(n)) &\Longleftrightarrow \Omega(max\{f(n), g(n)\})
\end{align*}
\textbf{Prove } $h \in O(f+g) \Longleftrightarrow h \in O(max(f,g))$ \\
Suppose $h \in O(f + g)$, then $\exists c > 0, n_{0} > 0$ such that
\begin{align*}
  h &\leq c(f + g) ~~~\forall n \geq n_{0} \\
  h &\leq cf + cg
\end{align*}
Without loss of generality, let $max(f, g) = f$, then $f \geq g$ \\
Then
\begin{align*}
  h &\leq cf + cg \leq cf + cf \\
  h &\leq cf + cg \leq 2cf \\
  h &\leq cf + cg \leq 2c[max(f,g)] ~~~\forall n \geq n_{0}
\end{align*}
Let $c_{1} = 2c$, then
$$h \leq c_{2}max(f,g)$$
So
$$h \leq c(f + g) \leq c_{2}max(f,g) ~~~\forall n \geq n_{0}$$
Thus
$$h \in O(max(f,g)) \qed$$

\section{Summation Formulas}
Arithmetic:
\begin{flalign}
  & \sum_{i=0}^{n-1}(a + di) = na + \frac{dn(n-1)}{2} \in \theta(n^{2}) ~\text{for } d \not = 0 & \nonumber
\end{flalign}
Geometric:
\begin{flalign}
  &\sum_{i=0}^{n-1}ar^{i} =
  \begin{cases}
    a\frac{r^{n} - 1}{r - 1} &\in \theta(r^{n}) \text{ if } r > 1 \\
    na &\in \theta(n) ~\text{ if } r = 1 \\
    a\frac{1 - r^{n}}{1 - r} &\in \theta(1) ~\text{ if } 0 < r < 1
  \end{cases}& \nonumber
\end{flalign}
Harmonic:
\begin{flalign}
  & H_{n} = \sum_{i=1}^{n}\frac{1}{i} \in \theta(\log n) & \nonumber
\end{flalign}
More:
\begin{flalign}
  \text{1)}~~~~~&\sum_{i=1}^{n}ir^{i} = \frac{nr^{n+1}}{r - 1} - \frac{r^{n+1} - r}{(r-1)^{2}} & \nonumber \\
  \text{2)}~~~~~&\sum_{i=1}^{\infty}\frac{1}{i^{2}} = \frac{\pi}{6} & \nonumber \\
  \text{3)}~~~~~&\text{for } k \geq 0, \sum_{i=1}^{n}i^{k} \in \theta(n^{k+1}) & \nonumber \\
  \text{4)}~~~~~&n! \in \theta(\frac{n^{\frac{n+1}{2}}}{e^{n}}) & \nonumber \\
  \text{5)}~~~~~&\log n! \in \theta(n \log n) & \nonumber
\end{flalign}

\section{Heaps}
A \emph{max-heap} is a binary tree with the following two properties (min-heap has opposite order property):
\begin{itemize}
  \item Structural Property: All the levels of a heap are completely filled, except (possibly) for the last level.
  The filled items in the last level are \emph{left-justified}.
  \item Heap-Order Property: For any node \emph{i}, key (priority) of parent of \emph{i} is larger than or equal to key of \emph{i}.
\end{itemize}

\begin{theorem}
  Height of a heap with $n$ nodes is $\theta(\log n)$.
\end{theorem}
\textbf{Proof} \\
There are $k - 1$ filled levels above \emph{n}\textsuperscript{th} node, and these levels contain $2^{k-1}$ nodes. \\
Then the \emph{n}\textsuperscript{th} node is on the \emph{k}\textsuperscript{th} level, $n - (2^{k} - 1)$ from left. \\
Note we can always choose unique $k$ such that $2^{k} \leq n \leq 2^{k+1} - 1$ via induction
\[
\underbrace{1 + (2^{0} + 2^{1} + \dots + 2^{k-1})}_{\substack{\text{Total number of nodes in a full}\\\text{tree of height }k-1\text{, plus one,}\\\text{left justified node }n\text{ in level }k}} \leq
n \leq
\underbrace{2^{0} + 2^{1} + \dots + 2^{k}}_{\substack{\text{Total number of nodes in}\\\text{a full tree of height }k}}
\]
Since nodes are added from left to right on the bottom level, the tree with $n$ nodes must be height $k$; since it is bounded on both sides by trees of height $k$.
Thus
$$2^{k} \leq n \leq 2^{k+1} - 1$$
$$k \leq \log n \leq \log(2^{k-1}-1) < \log 2^{k+1} = k + 1$$
$\therefore$ height of an heap is $\theta(\log n)$. $\hfill \qed$

\subsection{Insertion in Heaps}
Place the new key at the first free leaf.
The heap-order property might be violated, so perform a \emph{bubble-up}.
The new item bubbles up until it reaches its correct place.
\begin{algorithmic}
  \Function{bubble-up}{v} \\
  v: a node of the heap
  \While{parent(v) exists \textbf{and} key(parent(v)) $<$ key(v)}
    \State swap v and parent(v)
    \State $v \leftarrow$ parent(v)
  \EndWhile
  \EndFunction
\end{algorithmic}
Priority queue realization using heap:
\begin{algorithmic}
  \Function{Heap-Insert}{A, x} \\
  A: an array-based heap, x: a new item
  \State size(A) $\leftarrow$ size(A) + 1
  \State A[size(A) - 1] $\leftarrow$ x
  \State \Call{bubble-up}{A[size(A) - 1]}
  \EndFunction
\end{algorithmic}
Running time: $O(\log n)$ \\

\subsection{Delete Max In Heaps}
Maximum item of a heap is just the root node; replace the root by the last leaf (last leaf is then taken out).
Perform a \emph{bubble-down} since heap-order property may be violated.
\begin{algorithmic}
  \Function{bubble-down}{v} \\
  v: a node in the heap
  \While{v is not a leaf}
    \State u $\leftarrow$ child of v with largest key
    \If{key(u) $>$ key(v)}
      \State swap v and u
      \State v $\leftarrow$ i
    \Else
      \State \textbf{break}
    \EndIf
  \EndWhile
  \EndFunction
\end{algorithmic}
Priority queue realization using heap:
\begin{algorithmic}
  \Function{heap-delete-max}{A} \\
  A: an array-based heap
  \State max $\leftarrow$ A[0]
  \State swap(A[0], A[size(A) - 1])
  \State size(A) $\leftarrow$ size(A) - 1
  \State \Call{bubble-down}{A[0]}
  \State \Return{max}
  \EndFunction
\end{algorithmic}
Running time: $(\log n)$

\subsection{Storing Heaps in Arrays}
Let $H$ be a heap (binary tree) of $n$ items and let $A$ be an array of size $n$.
Store root in $A[0]$ and continue with elements \emph{level by level} from top to bottom, in each level \emph{left to right}. \\
The \emph{left} child (if it exists) of $A[i] = A[2i + 1]$ \\
The \emph{right} child (if it exists) of $A[i] = A[2i + 2]$ \\
The \emph{parent} ($i \not = 0$) of $A[i] = A[\lfloor \frac{i-1}{2} \rfloor]$ \\

\subsection{Building Heaps}
\begin{algorithmic}
  \Function{heapify}{A} \\
  A: an array
  \State n $\leftarrow$ size(A) - 1
  \For{i $\leftarrow \lfloor\frac{n}{2}\rfloor$ down to 0}
    \State \Call{bubble-down}{A[i]}
  \EndFor
  \EndFunction
\end{algorithmic}
Running time: $\theta(\log n)$

\section{Sorting/Random Algorithms}
\emph{quick-select} and the related algorithm \emph{quick-sort} rely on two subroutines:
\begin{itemize}
  \item \emph{choose-pivot}(A): Choose an index $i$ such that $A[i]$ will make a good pivot (hopefully near the middle of the order)
  \item \emph{partition}(A,p): Using pivot $A[p]$, rearrange $A$ so that \\
  all items less than or equal to the pivot come first, \\
  followed by the pivot, \\
  followed by all items greater than the pivot.
\end{itemize}

A \emph{randomized algorithm} is one which relies on some random number in addition to the input. \\
The cost will depend on the input and the random numbers used. \\
Las Vegas algorithm is a randomized algorithm that always gives the correct results; that is, it always produce the correct result or it informs about failure. \\
Monte Carlo algorithm is a randomized algorithm whose running time is deterministic (given a particular input, will always produce the output), but whose output may be incorrect with a certain (typically small) probability.

\subsection{Expected Running Time - Randomized Algorithms}
Define $T(I, R)$ as the running time of the randomized algorithm for a particular input $I$ and the sequence of random numbers $R$. \\
The \emph{expected running time} $T^{(exp)}(I)$ of a randomized algorithm for a particular input $I$ is the ``expected'' value for $T(I,R)$:
$$T^{(exp)}(I) = \textbf{E}[T(I,R)] = \sum_{R}T(I,R) \cdot Pr[R]$$
The \emph{worse-case expected running time} is then
$$T^{(exp)}(n) = \underset{size(I) = n}{\max} T^{(exp)}(I)$$
The worst-, best-, and average-case expected times are the same for many randomized algorithm.

\subsection{Partition Algorithm}
\begin{algorithmic}
  \Function{partition}{A,p} \\
  A: array of size $n$, p: integer such that $0 \leq p < n$
  \State swap(A[0], A[p])
  \State $i \leftarrow 1$, $j \leftarrow n - 1$
  \Loop
    \While{$i < n$ \textbf{and} $A[i] \leq A[0]$}
      \State $i \leftarrow i + 1$
    \EndWhile
    \While{$j \geq 1$ \textbf{and} $A[j] > A[0]$}
      \State $j \leftarrow j - 1$
    \EndWhile
    \If{$j < i$}
      \State \textbf{break}
    \Else
      \State swap(A[i], A[j])
    \EndIf
  \EndLoop
  \State swap(A[0], A[j])
  \State \Return{j}
  \EndFunction
\end{algorithmic}

\subsection{Selecting a Pivot and Quick Select}
\subsubsection{First Idea}  \label{first-pivot}
Always select first element in array
\begin{algorithmic}
  \Function{choose-pivot-1}{A}
  \State \Return{A[0]}
  \EndFunction
\end{algorithmic}

\begin{algorithmic}
  \Function{quick-select-1}{A, k} \\
  A: array of size $n$, k: integer such that $0 \leq k < n$
  \State $p \leftarrow$ \Call{choose-pivot-1}{A}
  \State $i \leftarrow$ \Call{partition}{A,p}
  \If{$i = k$}
    \State \Return{A[i]}
  \ElsIf{$i > k$}
    \State \Return{\Call{quick-select-1}{$A[0, 1, \dots, i-1], k$}}
  \ElsIf{$i < k$}
    \State \Return{\Call{quick-select-1}{$A[i+1, i+2, \dots, n-1], k-i-1$}}
  \EndIf
  \EndFunction
\end{algorithmic}

\textbf{Worst-Case Analysis} \\
Recursive call could always have size $n-1$. \\
Recurrence given by
$
T(n) =
\begin{cases}
T(n-1) + cn &n \geq 2 \\
d &n = 1
\end{cases}
$ \\
Solution: $T(n) = cn + c(n-1) + c(n-2) + \dots + c \cdot 2 + d \in \theta(n^{2})$ \\

\textbf{Best-Case Analysis} \\
First chosen pivot could be the \emph{k}\textsuperscript{th} element. \\
No recursive calls; total cost if $\theta(n)$. \\

\textbf{Average-Case Analysis} \\
Assume all $n!$ permutations are equally likely. \\
Average cost is sum of costs for all permutations, divided by $n!$ \\
Define $T(n,k)$ as average cost for selecting \emph{k}\textsuperscript{th} item from size-n array:
$$T(n,k) = cn + \frac{1}{n}\left(\sum_{i=0}^{k-1}T(n-i-1,k-i-1) + \sum_{i=k+1}^{n-1}T(i,k)\right)$$
For simplicity, define $T(n) = \underset{0 \leq k < n}{\max} T(n,k)$ \\
The cost is determine by $i$, the position of the pivot A[0]. \\
For more than half of the $n!$ permutations, $\frac{n}{4} \leq i \leq \frac{3n}{4}$ \\

In this case, the recursive call will have length at mosts $\lfloor\frac{3n}{4}\rfloor$, for any $k$.
The average cost is then given by
\[
T(n) \leq
\begin{cases}
cn + \frac{1}{2}\left(T(n) + T(\lfloor\frac{3n}{4}\rfloor)\right) &n \geq 2 \\
d &n = 1
\end{cases}
\]
Rearranging gives:
\begin{align*}
  T(n) &\leq 2cn + T(\lfloor\frac{3n}{4}\rfloor) \\
  &\leq 2cn + 2c(\frac{3n}{4}) + 2c(\frac{9n}{16}) + \dots + d \\
  &\leq d + 2cn\sum_{i=0}^{\infty}(\frac{3}{4})^{i} \in O(n)
\end{align*}
T(n) \emph{must} be $\Omega(n)$, so $T(n) \in \theta(n)$.

\subsubsection{Second Idea} \label{second-pivot}
With the probability at least $\frac{1}{2}$, the random pivot has position $\frac{n}{4} \leq i \leq \frac{3n}{4}$.
\begin{algorithmic}
  \Function{choose-pivot-2}{A}
  \State \Return{\Call{random}{n}}
  \EndFunction
\end{algorithmic}

\begin{algorithmic}
  \Function{quick-select-2}{A, k} \\
  A: array of size $n$, k: integer such that $0 \leq k < n$
  \State $p \leftarrow$ \Call{choose-pivot-2}{A}
  \State $i \leftarrow$ \Call{partition}{A,p}
  \If{$i = k$}
    \State \Return{A[i]}
  \ElsIf{$i > k$}
    \State \Return{\Call{quick-select-2}{$A[0, 1, \dots, i-1], k$}}
  \ElsIf{$i < k$}
    \State \Return{\Call{quick-select-2}{$A[i+1, i+2, \dots, n-1], k-i-1$}}
  \EndIf
  \EndFunction
\end{algorithmic}

\subsubsection{Third Idea} \label{third-pivot}
``Medians-of-five'' algorithm for pivot selection. \\
This \emph{mutually recursive} approach is to be $\theta(n)$ in the worst case.
\begin{algorithmic}
  \Function{choose-pivot-3}{A}
  \State $m \leftarrow \lfloor\frac{n}{5}\rfloor - 1$
  \For{$i \leftarrow 0$ to $m$}
    \State $j \leftarrow$ index of median of $A[5i, \dots, 5i+4]$
    \State swap($A[i],A[j]$)
  \EndFor
  \State \Return{\Call{quick-select-3}{$A[0,\dots,m], \lfloor\frac{m}{2}\rfloor$}}
  \EndFunction
\end{algorithmic}

\begin{algorithmic}
  \Function{quick-select-3}{A, k} \\
  A: array of size $n$, k: integer such that $0 \leq k < n$
  \State $p \leftarrow$ \Call{choose-pivot-3}{A}
  \State $i \leftarrow$ \Call{partition}{A,p}
  \If{$i = k$}
    \State \Return{A[i]}
  \ElsIf{$i > k$}
    \State \Return{\Call{quick-select-3}{$A[0, 1, \dots, i-1], k$}}
  \ElsIf{$i < k$}
    \State \Return{\Call{quick-select-3}{$A[i+1, i+2, \dots, n-1], k-i-1$}}
  \EndIf
  \EndFunction
\end{algorithmic}

\subsection{QuickSort}
\begin{algorithmic}
  \Function{quick-sort}{A} \\
  A: array of size $n$
  \If{$n \leq 1$}
    \State \Return{}
  \EndIf
  \State $p \leftarrow$ \Call{choose-pivot}{A}
  \State $i \leftarrow$ \Call{partition}{A,p}
  \State \Call{quick-sort}{$A[0, 1, \dots, i-1]$}
  \State \Call{quick-sort}{$A[i+1, i+2, \dots, size(A) - 1]$}
  \EndFunction
\end{algorithmic}

\textbf{Worst case}: \\
If using first idea (\ref{first-pivot}) or second idea (\ref{second-pivot}), the worst-case running time is
$$T^{(worst)}(n) = T^{(worst)}(n-1) + \theta(n) \in \theta(n^{2})$$
If using third idea (\ref{third-pivot}), the worst-case running them is then $\theta(n\log n)$ \\

\textbf{Best case}: \\
Regardless of pivot idea, the best running time is
$$
T^{(best)}(n) =
T^{(best)}(\lfloor\frac{n-1}{2}\rfloor) +
T^{(best)}(\lceil\frac{n-1}{2}\rceil) + \theta(n) \in \theta(n\log n)
$$

%%%%%%%%%%%%
%% REVIEW %%
%%%%%%%%%%%%
\newpage
\section{Review}
\textbf{[A] Prove} $\frac{1}{n} \in o(1)$
\begin{flalign}
  &\frac{1}{n} < c & \notag \\
  &1 < cn & \notag \\
  &n > \frac{1}{c} & \notag \\
  &\text{Choose } n_{0} = \frac{2}{c} &\notag \\
  &\text{Given $c > 0$, set } n_{0} = \frac{2}{c} &\notag \\
  &\frac{1}{n} \leq \frac{1}{n_0} \leq \frac{1}{2/c} & \notag \\
  &= \frac{c}{2} & \notag \\
  &< c & \blacksquare \notag
\end{flalign}
\newline

\textbf{[B] Prove} $\frac{1}{n\sqrt{n}} \not\in O(\frac{1}{n^2}$
\begin{flalign}
  &\exists c, n_{0} > 0 \text{ such that} & \notag \\
  &\frac{1}{n\sqrt{n}} \leq \frac{c}{n^2} & \notag \\
  &\frac{n^{2}}{n\sqrt{n}} \leq \frac{n^{2}c}{n^{2}} & \notag \\
  &\frac{n}{\sqrt{n}} \leq c & \notag \\
  &\sqrt{n} \leq c & \notag \\
  & n \leq c^{2} & \notag \\
  &\textbf{Contradiction. Thus } n > c^{2} &\blacksquare \notag
\end{flalign}
\newline

\textbf{[C]} Suppose you own \emph{n} electronic devices.
You have \emph{n} charger cables associated with each phone.
Each plug is slightly different, but you can't compare plugs with each other.
You can only find which charger fits with each phone by plugging it in. \\
Give a randomized $O(n\log n)$ algorithm:

\end{document}

%%%%%%%%%%%%%%%%%%%%%
%% D O C U M E N T %%
%%%%%%%%%%%%%%%%%%%%%
